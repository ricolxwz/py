---
title: 数组索引
icon: material/dice-multiple-outline
comments: true
---

???+ info "信息"

    默认省略导入`import numpy as np`.

???+ tip "Tip"

    `x[([exp1], [exp2], ..., [expN])]`和`x[[exp1], [exp2], ..., [expN]]`是相等的, 后者是前者的语法糖.

## 基础索引

???+ warning "注意"

    基础索引产生的新数组是[视图](/NumPy/视图副本/#视图).

### 单一元素索引 {#单一元素索引}

在一维数组中的单一元素索引和在原生列表中的单一元素索引没有区别. 都是从0开始, 能够接受负数表示从末尾开始索引. 同样对于多维数组来说, 也和原生列表相似. 

???+ example "例子"

    ```
    >>> x = np.arange(10)
    >>> x[2]
    2
    >>> x[-2]
    8
    >>> x.shape = (2, 5) # 不会创建新视图, 因为这是修改原数组的元数据
    >>> x[1, 3]
    8
    >>> x[1, -1]
    9
    ```

    ???+ note "笔记"

        如果用比维度少的索引来索引多维数组, 会得到一个子维数组, 这个子维数组是一个[视图](/NumPy/视图副本/#视图). 所以常用单一元素索引来执行降维操作.

        ???+ example "例子"

            ```
            >>> x = np.arange(10)
            >>> x.shape = (2, 5)
            >>> x[0]
            array([0, 1, 2, 3, 4])
            >>> x[0].base # 使用base属性判断是视图还是副本
            array([[0, 1, 2, 3, 4],
                   [5, 6, 7, 8, 9]]) # 为原数组所以为视图
            >>> x[0][2]
            ```

    ???+ tip "Tip"

        `x[u, v] == x[u][v]`但是`x[u][v]`的效率更低, 因为`x[u]`会创建一个新视图, 随后在这个新视图上再进行索引.
    
### 切片

???+ danger "特别注意"

    - 降维操作: 当使用一个整数`i`索引的时候, 即[单一元素索引](#单一元素索引). 返回数组的维度减少了1. 即`a[0]`和`a[0:1]`在数值上虽然是相同的, 但是前者在维度上前者减1, 后者保持不变. 

        ???+ example "例子"

            ```
            >>> a = np.arange(12)
            >>> a
            array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
            >>> a[1] # 返回的维度减少了1, 从一维变为零维
            1
            >>> a[0:1]
            array([0]) # 仍然为一维
            >>> arr = np.array([[1, 2, 3], [4, 5, 6]])
            >>> arr[0] # 返回的维度减少了1, 从二维变为一维
            array([1, 2, 3])
            >>> arr[0:1] # 仍然为二维
            array([[1, 2, 3]])
            ```
    
    - 升维操作: NumPy提供的`newaxis`对象或者也可以用`None`可以用来在返回的数组中新增一个维度. 

        ???+ example "例子"

            ```
            >>> arr = np.array([[1, 2, 3],
                                [4, 5, 6]])
            >>> arr.shape
            (2, 3)
            >>> expanded_arr1 = arr[np.newaxis, ...]
            >>> expanded_arr1
            array([[[1, 2, 3],
                    [4, 5, 6]]])
            >>> expanded_arr1.shape
            (1, 2, 3)
            >>> expanded_arr2 = arr[:, np.newaxis, :]
            >>> expanded_arr2
            array([[[1, 2, 3]],

                   [[4, 5, 6]]])
            >>> expanded_arr2.shape
            (2, 1, 3)
            >>> expanded_arr3 = arr[..., np.newaxis]
            >>> expanded_arr3
            array([[[1],
                    [2],
                    [3]],

                   [[4],
                    [5],
                    [6]]])
            >>> expanded_arr3.shape
            (2, 3, 1)
            ```

???+ warning "注意"

    - NumPy切片创建的是[视图](/NumPy/视图副本/#视图), 而不像内置的Python序列如字符串, 元组和列表那样经过切片产生的是一个副本.
    - 从大数组中切片得到一个小的数组之后, 如果小数组不再发挥作用, 必须要小心, 因为小数组中的访问缓冲区和大数组中的数据缓冲区都是同一个, 当要删除大数组时, 必须删除全部由其派生的小数组, 数据缓冲区/内存才会被释放. 所以在这种情况下, 建议使用[副本](/NumPy/视图副本/#副本).
    - 使用切片对象进行切片不会导致维度的增加或者减少.

每一个维度使用`[start]:[end]:[stride]`即切片对象进行切片, 维度之间用`,`进行分割, 第一个切片对象表示最高维, 第二个切片对象表示次高维, ...

???+ note "笔记"

    假设n是某一个维度的待切片的元素的数量.

    - 含义: 

        - `[start]`: 表示想要的第一项的下标; 若为负数, 表示的下标为`n+[start]`
        - `[end]`: 表示第一个不想要的项的下标; 若为负数, 表示的下标为`n+[end]`
        - `[stride]`: 定义了向前(负数)还是向后(正数)以及步长(绝对值)

    - 默认值:

        - `[start]`: 若`[stride]`小于0, 默认为n-1; 若`[stride]`大于0, 默认为0. 
        - `[end]`: 若`[stride]`小于0, 默认为-n-1; 若`[stride]`大于0, 默认为n
        - `[stride]`: 默认为1

???+ example "例子"

    === "一维数组切片"

        ```
        >>> a = np.arange(12)
        >>> a
        array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
        >>> a[:4]
        array([0, 1, 2, 3])
        >>> a[1:]
        array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
        >>> a[1:3]
        array([1, 2])
        >>> a[1:10:2]
        array([1, 3, 5, 7, 9])
        >>> a[-3:3]
        array([], dtype=int64) # 步长默认为1, 所以没有选中任何元素
        >>> a[-3:3:-1]
        array([9, 8, 7, 6, 5, 4])
        >>> a[::-1] # 步长为1, 是一个负数, 所以[start]默认为11, [end]默认为-13
        array([11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0])
        ```

    === "二维数组切片"

        ```
        >>> a = np.array([[1, 2, 3], [4, 5, 6]])
        >>> a
        array([[1, 2, 3],
               [4, 5, 6]])
        >>> a[:, ::2]
        array([[1, 3],
               [4, 6]])
        >>> a[0, ::2]
        array([1, 3])
        >>> a[1::, 1:3]
        array([[5, 6]])
        >>> a[1]  # 降维操作, 维度降为一维
        array([4, 5, 6])
        >>> a[::-1, 1:2]
        array([[5],
               [2]])
        >>> a[::, ::-1]
        array([[3, 2, 1],
               [6, 5, 4]])
        ```

???+ tip "Tip"

    - `[start]:[end]:[stride]`与由`slice`类创建的切片对象含义相同.

        ???+ example "例子"

            ```
            >>> arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
            >>> s = slice(2, 8, 2)
            >>> arr[s]
            [2, 4, 6]
            ```

    - 当切片对象的数量小于数组的维度`N`的时候, 剩余的维度会默认创建`:`切片对象(即选择整个维度)

        ???+ example "例子"

            === "例子1"

                ```
                >>> arr = np.arange(24).reshape((4, 3, 2))
                >>> arr
                array([[[ 0,  1],
                        [ 2,  3],
                        [ 4,  5]],

                       [[ 6,  7],
                        [ 8,  9],
                        [10, 11]],

                       [[12, 13],
                        [14, 15],
                        [16, 17]],

                       [[18, 19],
                        [20, 21],
                        [22, 23]]])
                >>> arr[0:1] # 保持3维
                array([[[0, 1],
                        [2, 3],
                        [4, 5]]])
                >>> arr[0] # 降为2维
                array([[0, 1],
                       [2, 3],
                       [4, 5]])
                ```

                这里切片对象只有一个, 即`0:1`, 剩余的2维会默认创建一个`:`切片对象, 即最终的形式为`arr[0:1, :, :]`, 即选择第一个维度的第一个元素, 同时选择第二个和第三个维度的所有元素.
            
            === "例子2"

                ```
                >>>  x = np.array([[[1],[2],[3]], [[4],[5],[6]]])
                >>> x.shape
                (2, 3, 1)
                >>> x[1:2]
                array([[[4],
                        [5],
                        [6]]])
                ```
    
    - 若除了第p个切片对象外, 其他的切片对象都是`:`. 则返回的数组是通过通过p轴由第p个切片对象选定的元素堆叠形成的.

        ???+ example "例子"

            ```
            >>> arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
            >>> arr
            array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])
            >>> arr.shape
            (3, 3)
            >>> arr[:, 0:3:2]
            array([[1, 3],
                   [4, 6],
                   [7, 9]])
            ```

            返回的数组仍然是二维, 第二个切片对象`0:3:2`对每一个一维数组进行切片, 然后通过堆叠形成最终的返回数组.

    - 若存在多个非`:`的切片对象, 则其效果和分批切片是一样的. 因此`x[[ind1], ..., [ind2], :]`和`x[[ind1][..., [ind2], :]`是等价的.

        ???+ example "例子"

            ```
            >>> arr = np.arange(24).reshape((4, 3, 2))
            >>> arr
            array([[[ 0,  1],
                    [ 2,  3],
                    [ 4,  5]],

                    [[ 6,  7],
                    [ 8,  9],
                    [10, 11]],

                    [[12, 13],
                    [14, 15],
                    [16, 17]],

                    [[18, 19],
                    [20, 21],
                    [22, 23]]])
            >>> arr[0:1][:, 1:2] #  arr[0:1]返回的仍然是一个三维的数组, 所以要在二维中切片, 保持三维不变, 所以是arr[0:1][:, 1:2]
            array([[[2, 3]]])
            >>> arr[0:1, 1:2]
            array([[[2, 3]]])
            >>> arr[0:1][1:2]  # arr[0:1]返回的仍然是一个三维的数组, 仍然在三维中切片, 由于经过第一轮切片之后三维中只剩下第一个元素了, 所以第二轮切片中无法切出三维中的第二个元素, 所以返回一个空的三维数组
            array([], shape=(0, 3, 2), dtype=int64) 
            >>> arr[0][1:2] # arr[0]返回的是一个降维之后的二维数组, 这个二维数组在数值上和三维数组的第一个元素是相同的, [1:2]表示对这个二维数组进行切片
            array([[2, 3]])
            ```

            所以`arr[0:1][:, 1:2]`和`arr[0:1, 1:2]`是等价的.
        
    - 一些工具如Ellipsis可以代替多个`:`切片对象. 

        ???+ example "例子"

            ```
            >>> arr = np.arange(24).reshape((4, 3, 2))
            >>> arr
            array([[[ 0,  1],
                    [ 2,  3],
                    [ 4,  5]],

                    [[ 6,  7],
                    [ 8,  9],
                    [10, 11]],

                    [[12, 13],
                    [14, 15],
                    [16, 17]],

                    [[18, 19],
                    [20, 21],
                    [22, 23]]])
            >>> arr[..., 0:1] # 保持三维
            array([[[ 0],
                    [ 2],
                    [ 4]],

                [[ 6],
                    [ 8],
                    [10]],

                [[12],
                    [14],
                    [16]],

                [[18],
                    [20],
                    [22]]])
            >>> arr[..., 0] # 降维至二维
            array([[ 0,  2,  4],
                [ 6,  8, 10],
                [12, 14, 16],
                [18, 20, 22]])
            >>> arr[:, :, 0:1] # 保持三维
            array([[[ 0],
                    [ 2],
                    [ 4]],

                [[ 6],
                    [ 8],
                    [10]],

                [[12],
                    [14],
                    [16]],

                [[18],
                    [20],
                    [22]]])
            >>> arr[:, :, 0] # 降维至二维
            array([[ 0,  2,  4],
                [ 6,  8, 10],
                [12, 14, 16],
                [18, 20, 22]])
            ```

            可以看出, `arr[:, :, 0]`和`arr[..., 0]`的效果完全一样, `arr[:, :, 0:1]`和arr[..., 0]`的效果完全一样.


[^1]: Indexing on ndarrays—NumPy v2.0 Manual. (n.d.). Retrieved June 21, 2024, from https://numpy.org/doc/stable/user/basics.indexing.html
[^2]: 理解python索引和切片 · Issue #15 · qiwihui/blog. (n.d.). GitHub. Retrieved June 21, 2024, from https://github.com/qiwihui/blog/issues/15