---
title: 数组索引
icon: material/dice-multiple-outline
comments: true
---

???+ info "信息"

    - 前置知识:
        - [数组构建](/NumPy/数组构建)
        - [视图/副本](/NumPy/视图副本)
        - [广播](/NumPy/广播): [高级索引](#高级索引)
    - 默认省略导入`import numpy as np`.

## 选择对象

`x[obj]`, `obj`即为选择对象.

选择对象是用来索引的对象, 根据选择对象的不同, 可以判断属于[基础索引](#基础索引)还是[高级索引](#高级索引).

- 选择对象为元祖且仅含有数值, 切片对象: 属于[基础索引](#基础索引)
- 选择对象为非元祖或一个含有至少一个序列(如列表, 元祖)或nd数组的元祖: 属于[高级索引](#高级索引)

## 基础索引 {#基础索引}

选择对象为元祖且仅含有数值或者切片对象时的索引属于基础索引.

???+ warning "注意"

    基础索引产生的新数组是[视图](/NumPy/视图副本/#视图).

???+ tip "Tip"

    `x[([exp1], [exp2], ..., [expN])]`和`x[[exp1], [exp2], ..., [expN]]`是相等的, 后者是前者的语法糖.

### 维度 {#返回数组的维度}

???+ danger "特别注意"

    - 降维操作: 当使用一个整数`i`索引的时候, 即[单一元素索引](#单一元素索引). 返回数组的维度减少了1. 即`a[0]`和`a[0:1]`在数值上虽然是相同的, 但是前者在维度上前者减1, 后者保持不变. 即[切片索引](#切片索引)不会对维度造成改变.

        ???+ example "例子"

            ```
            >>> a = np.arange(12)
            >>> a
            array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
            >>> a[1] # 返回的维度减少了1, 从一维变为零维
            1
            >>> a[0:1]
            array([0]) # 仍然为一维
            >>> arr = np.array([[1, 2, 3], [4, 5, 6]])
            >>> arr[0] # 返回的维度减少了1, 从二维变为一维
            array([1, 2, 3])
            >>> arr[0:1] # 仍然为二维
            array([[1, 2, 3]])
            ```
    
    - 升维操作: NumPy提供的`newaxis`对象或者也可以用`None`可以用来在返回的数组中新增一个维度. 

        ???+ example "例子"

            ```
            >>> arr = np.array([[1, 2, 3],
                                [4, 5, 6]])
            >>> arr.shape
            (2, 3)
            >>> expanded_arr1 = arr[np.newaxis, ...]
            >>> expanded_arr1
            array([[[1, 2, 3],
                    [4, 5, 6]]])
            >>> expanded_arr1.shape
            (1, 2, 3)
            >>> expanded_arr2 = arr[:, np.newaxis, :]
            >>> expanded_arr2
            array([[[1, 2, 3]],

                   [[4, 5, 6]]])
            >>> expanded_arr2.shape
            (2, 1, 3)
            >>> expanded_arr3 = arr[..., np.newaxis]
            >>> expanded_arr3
            array([[[1],
                    [2],
                    [3]],

                   [[4],
                    [5],
                    [6]]])
            >>> expanded_arr3.shape
            (2, 3, 1)
            ```

        ???+ tip "Tip"

            可以利用`np.newaxis`方便的将一维行向量和列向量之间转换. (在NumPy中, 列向量本质是个二维数组, 形状为`(n, 1)`; 行向量既可以用一维数组表示, 又可以用二维数组表示)

            ???+ example "例子"

                ```
                >>> a = np.array([0.0, 10.0, 20.0, 30.0]) # 一维行向量
                >>> a
                array([ 0., 10., 20., 30.])
                >>> a[:, np.newaxis] # 行向量变列向量, 维度加1
                array([[ 0.],
                       [10.],
                       [20.],
                       [30.]])
                ```

### 单一元素索引 {#单一元素索引}

在一维数组中的单一元素索引和在原生列表中的单一元素索引没有区别. 都是从0开始, 能够接受负数表示从末尾开始索引. 同样对于多维数组来说, 也和原生列表相似. 

???+ example "例子"

    ```
    >>> x = np.arange(10)
    >>> x[2]
    2
    >>> x[-2]
    8
    >>> x.shape = (2, 5) # 不会创建新视图, 因为这是修改原数组的元数据
    >>> x[1, 3]
    8
    >>> x[1, -1]
    9
    ```

    ???+ note "笔记"

        如果用比维度少的索引来索引多维数组, 会得到一个子维数组, 这个子维数组是一个[视图](/NumPy/视图副本/#视图). 所以常用单一元素索引来执行降维操作.

        ???+ example "例子"

            ```
            >>> x = np.arange(10)
            >>> x.shape = (2, 5)
            >>> x[0]
            array([0, 1, 2, 3, 4])
            >>> x[0].base # 使用base属性判断是视图还是副本
            array([[0, 1, 2, 3, 4],
                   [5, 6, 7, 8, 9]]) # 为原数组所以为视图
            >>> x[0][2]
            ```

    ???+ tip "Tip"

        `x[u, v] == x[u][v]`但是`x[u][v]`的效率更低, 因为`x[u]`会创建一个新视图, 随后在这个新视图上再进行索引.
    
### 切片索引 {#切片索引}

???+ warning "注意"

    - NumPy切片创建的是[视图](/NumPy/视图副本/#视图), 而不像内置的Python序列如字符串, 元组和列表那样经过切片产生的是一个副本.
    - 从大数组中切片得到一个小的数组之后, 如果小数组不再发挥作用, 必须要小心, 因为小数组中的访问缓冲区和大数组中的数据缓冲区都是同一个, 当要删除大数组时, 必须删除全部由其派生的小数组, 数据缓冲区/内存才会被释放. 所以在这种情况下, 建议使用[副本](/NumPy/视图副本/#副本).
    - 切片索引不会改变维度

每一个维度使用`[start]:[end]:[stride]`即切片对象进行切片, 维度之间用`,`进行分割, 第一个切片对象表示最高维, 第二个切片对象表示次高维, ...

???+ note "笔记"

    假设n是某一个维度的待切片的元素的数量.

    - 含义: 

        - `[start]`: 表示想要的第一项的下标; 若为负数, 表示的下标为`n+[start]`
        - `[end]`: 表示第一个不想要的项的下标; 若为负数, 表示的下标为`n+[end]`
        - `[stride]`: 定义了向前(负数)还是向后(正数)以及步长(绝对值)

    - 默认值:

        - `[start]`: 若`[stride]`小于0, 默认为n-1; 若`[stride]`大于0, 默认为0. 
        - `[end]`: 若`[stride]`小于0, 默认为-n-1; 若`[stride]`大于0, 默认为n
        - `[stride]`: 默认为1

???+ example "例子"

    === "一维数组切片"

        ```
        >>> a = np.arange(12)
        >>> a
        array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
        >>> a[:4]
        array([0, 1, 2, 3])
        >>> a[1:]
        array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
        >>> a[1:3]
        array([1, 2])
        >>> a[1:10:2]
        array([1, 3, 5, 7, 9])
        >>> a[-3:3]
        array([], dtype=int64) # 步长默认为1, 所以没有选中任何元素
        >>> a[-3:3:-1]
        array([9, 8, 7, 6, 5, 4])
        >>> a[::-1] # 步长为1, 是一个负数, 所以[start]默认为11, [end]默认为-13
        array([11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0])
        ```

    === "二维数组切片"

        ```
        >>> a = np.array([[1, 2, 3], [4, 5, 6]])
        >>> a
        array([[1, 2, 3],
               [4, 5, 6]])
        >>> a[:, ::2]
        array([[1, 3],
               [4, 6]])
        >>> a[0, ::2]
        array([1, 3])
        >>> a[1::, 1:3]
        array([[5, 6]])
        >>> a[1]  # 使用单一元素索引, 维度降为一维
        array([4, 5, 6])
        >>> a[::-1, 1:2]
        array([[5],
               [2]])
        >>> a[::, ::-1]
        array([[3, 2, 1],
               [6, 5, 4]])
        ```

???+ note "笔记"

    - `[start]:[end]:[stride]`与由`slice`类创建的切片对象含义相同.

        ???+ example "例子"

            ```
            >>> arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
            >>> s = slice(2, 8, 2)
            >>> arr[s]
            [2, 4, 6]
            >>> s1 = slice(None, None, 2)
            >>> arr[s1]
            [0, 2, 4, 6, 8]
            ```

    - 可以对切片之后的数组进行赋值操作, 但是不能添加元素. 在`x[obj] = [value]`中设置的值必须和`x[obj]`有相同的形状.

    - 当切片对象的数量小于数组的维度`N`的时候, 剩余的维度会默认创建`:`切片对象(即选择整个维度)

        ???+ example "例子"

            === "例子1"

                ```
                >>> arr = np.arange(24).reshape((4, 3, 2))
                >>> arr
                array([[[ 0,  1],
                        [ 2,  3],
                        [ 4,  5]],

                       [[ 6,  7],
                        [ 8,  9],
                        [10, 11]],

                       [[12, 13],
                        [14, 15],
                        [16, 17]],

                       [[18, 19],
                        [20, 21],
                        [22, 23]]])
                >>> arr[0:1] # 保持3维
                array([[[0, 1],
                        [2, 3],
                        [4, 5]]])
                >>> arr[0] # 使用单一元素索引, 降为2维
                array([[0, 1],
                       [2, 3],
                       [4, 5]])
                ```

                这里切片对象只有一个, 即`0:1`, 剩余的2维会默认创建一个`:`切片对象, 即最终的形式为`arr[0:1, :, :]`, 即选择第一个维度的第一个元素, 同时选择第二个和第三个维度的所有元素.
            
            === "例子2"

                ```
                >>>  x = np.array([[[1],[2],[3]], [[4],[5],[6]]])
                >>> x.shape
                (2, 3, 1)
                >>> x[1:2]
                array([[[4],
                        [5],
                        [6]]])
                ```
    
    - 若除了第p个切片对象外, 其他的切片对象都是`:`. 则返回的数组是通过通过p轴由第p个切片对象选定的元素堆叠形成的.

        ???+ example "例子"

            ```
            >>> arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
            >>> arr
            array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])
            >>> arr.shape
            (3, 3)
            >>> arr[:, 0:3:2]
            array([[1, 3],
                   [4, 6],
                   [7, 9]])
            ```

            返回的数组仍然是二维, 第二个切片对象`0:3:2`对每一个一维数组进行切片, 然后通过堆叠形成最终的返回数组.

    - 若存在多个非`:`的切片对象, 则其效果和分批切片是一样的. 因此`x[[ind1], ..., [ind2], :]`和`x[[ind1][..., [ind2], :]`是等价的.

        ???+ example "例子"

            ```
            >>> arr = np.arange(24).reshape((4, 3, 2))
            >>> arr
            array([[[ 0,  1],
                    [ 2,  3],
                    [ 4,  5]],

                    [[ 6,  7],
                    [ 8,  9],
                    [10, 11]],

                    [[12, 13],
                    [14, 15],
                    [16, 17]],

                    [[18, 19],
                    [20, 21],
                    [22, 23]]])
            >>> arr[0:1][:, 1:2] #  arr[0:1]返回的仍然是一个三维的数组, 所以要在二维中切片, 保持三维不变, 所以是arr[0:1][:, 1:2]
            array([[[2, 3]]])
            >>> arr[0:1, 1:2]
            array([[[2, 3]]])
            >>> arr[0:1][1:2]  # arr[0:1]返回的仍然是一个三维的数组, 仍然在三维中切片, 由于经过第一轮切片之后三维中只剩下第一个元素了, 所以第二轮切片中无法切出三维中的第二个元素, 所以返回一个空的三维数组
            array([], shape=(0, 3, 2), dtype=int64) 
            >>> arr[0][1:2] # 先使用了单一元素索引. arr[0]返回的是一个降维之后的二维数组, 这个二维数组在数值上和三维数组的第一个元素是相同的, [1:2]表示对这个二维数组进行切片
            array([[2, 3]])
            ```

            所以`arr[0:1][:, 1:2]`和`arr[0:1, 1:2]`是等价的.
        
    - 一些工具如Ellipsis可以代替多个`:`切片对象. 

        ???+ example "例子"

            ```
            >>> arr = np.arange(24).reshape((4, 3, 2))
            >>> arr
            array([[[ 0,  1],
                    [ 2,  3],
                    [ 4,  5]],

                    [[ 6,  7],
                    [ 8,  9],
                    [10, 11]],

                    [[12, 13],
                    [14, 15],
                    [16, 17]],

                    [[18, 19],
                    [20, 21],
                    [22, 23]]])
            >>> arr[..., 0:1] # 保持三维
            array([[[ 0],
                    [ 2],
                    [ 4]],

                   [[ 6],
                    [ 8],
                    [10]],

                   [[12],
                    [14],
                    [16]],

                   [[18],
                    [20],
                    [22]]])
            >>> arr[..., 0] # 使用单一元素索引, 降维至二维
            array([[ 0,  2,  4],
                [ 6,  8, 10],
                [12, 14, 16],
                [18, 20, 22]])
            >>> arr[:, :, 0:1] # 保持三维
            array([[[ 0],
                    [ 2],
                    [ 4]],

                   [[ 6],
                    [ 8],
                    [10]],

                   [[12],
                    [14],
                    [16]],

                   [[18],
                    [20],
                    [22]]])
            >>> arr[:, :, 0] # 使用单一元素索引, 降维至二维
            array([[ 0,  2,  4],
                [ 6,  8, 10],
                [12, 14, 16],
                [18, 20, 22]])
            ```

            可以看出, `arr[:, :, 0]`和`arr[..., 0]`的效果完全一样, `arr[:, :, 0:1]`和arr[..., 0]`的效果完全一样.

## 高级索引 {#高级索引}

选择对象为非元祖, 一个含有至少一个序列(如列表, 元祖)或nd数组的元祖时的索引属于高级索引.

???+ warning "注意"

    - 高级索引产生的新数组是[副本](/NumPy/视图副本/#副本).
    - 在学习这一小节之前, 强烈建议复习一遍[广播](/NumPy/广播).

???+ example "例子"

    `x[(1, 2, 3),]`和`x[(1, 2, 3)]`有显著不同, 第一个是语法糖写法, 原始写法是: `x[((1, 2, 3), )]`; 第二个就是原始写法. 可以看到第一个是元祖, 但是里面含有一个元祖序列, 所以属于高级索引. 第二个是元祖, 里面仅含有数值, 所以属于基础索引.


### 整数数组索引 {#整数数组索引}

选择对象为一个或多个整数索引数组的索引称为整数数组索引. 每个索引数组表示该维度中的多个索引. 

???+ note "笔记"

    - 索引数组, 被索引数组和选择对象

        ???+ example "例子"

            ```
            >>> x = np.array([[1, 2], [3, 4], [5, 6]])
            >>> index_arr1 = np.array([0, 2])
            >>> index_arr2 = np.array([0, 1])
            >>> x[index_arr1, index_arr2]
            array([1, 6])
            ```

            - `x[obj]`中的`obj`作为一个整体被称为索引对象
            - `index_arr1`和`index_arr2`为索引数组
            - `x`为被索引数组

    - 索引数组中允许出现负值

        ???+ example "例子"

            ```
            >>> x = np.arange(10, 1, -1)
            >>> index_arr = np.array([3, 3, -1, 8])
            >>> x[index_arr]
            array([7, 7, 2, 2])
            ```

???+ example "例子"

    === "例子1"

        ```
        >>> x = np.arange(10, 1, -1)
        >>> x
        array([10,  9,  8,  7,  6,  5,  4,  3,  2])
        >>> x[np.array([3, 3, 1, 8])]
        array([7, 7, 9, 2])
        >>> x[np.array([3, 3, -3, 8])]
        array([7, 7, 4, 2])
        ```

        很好理解, 如`x[np.array([3, 3, 1, 8])]`的意思是选中了索引值为`3, 3, 1, 8`上的元素, 分别对应`7, 7, 9, 2`.

    === "例子2"

        ```
        >>> x = np.array([[1, 2], [3, 4], [5, 6]])
        >>> x
        array([[1, 2],
                [3, 4],
                [5, 6]])
        >>> x[np.array([1, -1])]
        array([[3, 4],
                [5, 6]]) 
        >>> x[np.array([0, 2]), np.array([0, 1])]
        array([1, 6])
        >>> x[np.array([[0, 2], [0, 1]]), np.array([[1, 1], [0, 1]])]
        array([[2, 6],
                [1, 4]])
        >>> x[np.array([[0, 2], [1, 1]])]
        array([[[1, 2],
                [5, 6]],

                [[3, 4],
                [3, 4]]])
        ```

        - `x[np.array([0, 2]), np.array([0, 1])]`可以理解为最高纬上从`0, 2`选中一个索引值作为行索引值, 同时从最低纬`0, 1`选中一个索引值作为列索引值. 所以分别对应`0, 0`和`2, 1`处的元素
        - `x[np.array([[0, 2], [0, 1]]), np.array([[1, 1], [0, 1]])]`可以理解为最高纬从矩阵`[[0, 2], [0, 1]]`中选一个索引值作为行索引值, 同时最低维从矩阵`[[1, 1], [0, 1]]`选一个索引值作为列索引值. 所以分别对应`0, 1`, `2, 1`, `0, 0`, `1, 1`处的元素
        - `x[np.array([[0, 2], [1, 1]])]`可以理解未最高维从矩阵`[[0, 2], [0, 1]]`中选一个索引值作为行索引值, 列索引值默认为全部. 所以行索引值`0, 2`的为一个矩阵, 行索引值`0, 1`的为一个矩阵, 这两个矩阵合在一起得到了一个三维数组

#### 机理 {#整数数组索引的机理}

整数索引的机理如下:

- 索引数组的个数小于被索引数组的维度

    仅仅只会索引部分维度.

    ???+ example "例子"

        ```
        >>> x = np.array([[0, 1, 2],
                          [3, 4, 5],
                          [6, 7, 8]])
        >>> index_arr = np.array([0, 2]) # 被索引数组为二维, 索引数组只有1个
        >>> x[index_arr]
        array([[0, 1, 2],
               [6, 7, 8]])
        ```

        只选中了最高维度的索引值为`0`和`2`的元素, 即`[0, 1, 2]`和`[6, 7, 8]`.

    ???+ tip "Tip"

        对于三维以上的高维被索引对象, 如果有多于1个索引对象的情况下, 这些索引对象也会被广播至形状相同

- 索引数组的个数大于被索引数组的维度

    会报错, 无法进行索引操作.

    ???+ example "例子"

        ```
        >>> x = np.array([[0, 1, 2],
                          [3, 4, 5],
                          [6, 7, 8]])
        >>> index_arr1 = np.array([0, 1])
        >>> index_arr2 = np.array([0, 1])
        >>> index_arr3 = np.array([0, 1])
        >>> x[index_arr1, index_arr2, index_arr3]
        Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
        IndexError: too many indices for array: array is 2-dimensional, but 3 were indexed
        ``` 

        因为根本不存在`index_arr3`所要索引的维度.

- 索引数组的个数等于被索引数组的维度

    会索引全部的维度.

    ???+ example "例子"

        ```
        >>> x = np.array([[1, 2], [3, 4], [5, 6]])
        >>> x
        array([[1, 2],
                [3, 4],
                [5, 6]])
        >>> x[np.array([0, 2]), np.array([0, 1])]
        array([1, 6])
        >>> x[np.array([[0, 2], [0, 1]]), np.array([[1, 1], [0, 1]])]
        array([[2, 6],
                [1, 4]])
        ```

#### 形状 {#整数数组索引返回数组的维度}

结果数组的形状将是所有索引数组广播后的形状与被索引数组中任何未使用维度的形状的拼接.

???+ tip "Tip"

    若无法广播至形状相同, 报错: `IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes...`.

???+ example "例子"

    === "索引数组个数=被索引数组维度: 例子1"

        ```
        >>> x = np.array([[1, 2], [3, 4], [5, 6]])
        >>> index_arr1 = np.array([0, 1])
        >>> index_arr2 = np.int8(0)
        >>> x[index_arr1, index_arr2]
        array([1, 3])
        >>> x.shape
        (3, 2)
        >>> index_arr1.shape
        (2, )
        >>> index_arr2.shape
        ()
        >>> x[index_arr1, index_arr2].shape
        (2, )
        ```

        解释:

        1. 索引数组为`index_arr1`和`index_arr2`, 它们的形状不一致, 尝试广播

            定义:

            ```
            index_arr1的形状: 2
            index_arr2的形状: 
            ```

            1. 缺失的维度大小假设为1

                ```
                index_arr1的形状: 2
                index_arr2的形状: 1
                ```

            2. 从右到左比较每一个维度

                `2`和`1`, 其中一个维度是`1`, 兼容. 这表示可以广播.

            3. 广播结果数组的维度和输入的两个数组中最大的维度相等, 广播结果数组中每个维度的大小和输入的两个数组中对应维度的最大大小相等. 执行广播返回广播结果数组.

                ```
                index_arr1的形状: 2
                index_arr2的形状: 1
                广播结果数组的形状: 2
                ```

            即`index_arr2`会被广播至`index_arr2_broadcast`:

            ```
            array([0, 0]) 
            ```

        2. 获得广播结果之后, 上述操作相当于`x[index_arr1, index_arr2_broadcast]`, 由于索引数组的个数和被索引数组的维度相同, 所以被索引数组中没有未使用的维度, 不需要拼接, 所以返回数组的形状为`(2, )`.

    === "索引数组个数=被索引数组维度: 例子2"

        ```
        >>> x = np.array([[1, 2], [3, 4], [5, 6]])
        >>> index_arr1 = np.array([[0, 2], [0, 1]])
        >>> index_arr2 = np.array([1, 1])
        >>> x[index_arr1, index_arr2]
        array([[2, 6],
               [2, 4]]) 
        >>> x.shape
        (3, 2)
        >>> index_arr1.shape
        (2, 2)
        >>> index_arr2.shape
        (2, )
        >>> x[index_arr1, index_arr2].shape
        (2, 2)
        ```

        解释:

        1. 索引数组为`index_arr1`和`index_arr2`, 它们的形状不一致, 尝试广播

            定义:

            ```
            index_arr1的形状: 2 * 2
            index_arr2的形状:     2
            ```

            1. 缺失的维度大小假设为1

                ```
                index_arr1的形状: 2 * 2
                index_arr2的形状: 1 * 2
                ```

            2. 从右到左比较每一个维度

                - 最右边的维度: `2`和`2`, 相等, 兼容
                - 最左边的维度: `2`和`1`, 其中有一个为`1`, 兼容

                这表示可以广播.

            3. 广播结果数组的维度和输入的两个数组中最大的维度相等, 广播结果数组中每个维度的大小和输入的两个数组中对应维度的最大大小相等. 执行广播返回广播结果数组.

                ```
                index_arr1的形状: 2 * 2
                index_arr2的形状: 2 * 2
                广播结果数组的形状: 2 * 2
                ```

            即`index_arr2`会被广播至`index_arr2_broadcast`:

            ```
            array([[1, 1],
                [1, 1]])
            ```

        2. 获得广播结果之后, 上述操作相当于`x[index_arr1, index_arr2_broadcast]`, 由于索引数组的个数和被索引数组的维度相同, 所以被索引数组中没有未使用的维度, 不需要拼接, 所以返回数组的形状为`(2, 2)`.

    === "索引数组个数小于被索引数组维度: 例子1"

        ```
        >>> x = np.array([[1, 2], [3, 4], [5, 6]])
        >>> index_arr = np.array([[0, 2], [1, 1]]) 
        >>> x[index_arr]
        array([[[1, 2],
                [5, 6]],

               [[3, 4],
                [3, 4]]])
        >>> x.shape
        (2, 2)
        >>> index_arr.shape
        (2, 2)
        >>> x[index_arr].shape
        (2, 2, 2)
        ```

        解释:

        1. 只有一个索引数组, 无需广播
        2. 由于索引数组的个数和被索引数组的维度不同, 被索引数组中有一个未使用的维度, 所以返回数组的形状是索引数组的形状和被索引数组中未使用维度的形状的拼接, 被索引数组形状为`(2, 2)`, 未使用的维度形状为最后一个`2`, 即`(2, 2)`和`(, 2)`拼接. 所以返回数组的形状为`(2, 2, 2)`.

    === "索引数组个数小于被索引数组维度: 例子2"

        ```
        >>> x = np.random.rand(3, 4, 5)
        >>> x
        array([[[0.55466894, 0.51799315, 0.78576553, 0.01404337, 0.91133221],
                [0.92907975, 0.34859234, 0.43999193, 0.78651397, 0.01118377],
                [0.11216395, 0.49555847, 0.05999374, 0.48128311, 0.59141431],
                [0.28872995, 0.41625684, 0.38342567, 0.30393309, 0.1339127 ]],

               [[0.54648285, 0.39631359, 0.55229484, 0.92354217, 0.82128316],
                [0.36401197, 0.35216312, 0.48898517, 0.70356991, 0.84831573],
                [0.98796396, 0.13612022, 0.80908123, 0.72921041, 0.10010538],
                [0.97922128, 0.63756104, 0.34690585, 0.17157988, 0.97766046]],

               [[0.23605187, 0.45610698, 0.47592261, 0.26819004, 0.9662657 ],
                [0.54926935, 0.88694126, 0.31731081, 0.53162318, 0.2381443 ],
                [0.48462102, 0.67643836, 0.2836442 , 0.45926631, 0.9567899 ],
                [0.55863473, 0.86290501, 0.58643116, 0.05157535, 0.68392416]]])
        >>> index_arr1 = np.array([[0, 2], [1, 1]]) 
        >>> index_arr2 = np.array([0, 1])
        >>> x[index_arr1, index_arr2]
        array([[[0.55466894, 0.51799315, 0.78576553, 0.01404337, 0.91133221],
                [0.54926935, 0.88694126, 0.31731081, 0.53162318, 0.2381443 ]],

               [[0.54648285, 0.39631359, 0.55229484, 0.92354217, 0.82128316],
                [0.36401197, 0.35216312, 0.48898517, 0.70356991, 0.84831573]]])
        >>> x.shape
        (3, 4, 5)
        >>> index_arr1.shape
        (2, 2)
        >>> index_arr2.shape
        (2, )
        >>> x[index_arr1, index_arr2].shape
        (2, 2, 5)
        ```

        解释:

        1. 索引数组为`index_arr1`和`index_arr2`, 它们的形状不一致, 尝试广播 

            定义:

            ```
            index_arr1的形状: 2 * 2
            index_arr2的形状:     2
            ```

            1. 缺失的维度大小假设为1

                ```
                index_arr1的形状: 2 * 2
                index_arr2的形状: 1 * 2
                ```

            2. 从右到左比较每一个维度

                - 最右边的维度: `2`和`2`, 相等, 兼容
                - 最左边的维度: `2`和`1`, 其中有一个为`1`, 兼容

                这表示可以广播.

            3. 广播结果数组的维度和输入的两个数组中最大的维度相等, 广播结果数组中每个维度的大小和输入的两个数组中对应维度的最大大小相等. 执行广播返回广播结果数组.

                ```
                index_arr1的形状: 2 * 2
                index_arr2的形状: 2 * 2
                广播结果数组的形状: 2 * 2
                ```

            即`index_arr2`会被广播至`index_arr2_broadcast`:

            ```
            array([[0, 1],
                   [0, 1]])
            ```

        2. 获得广播结果之后, 上述操作相当于`x[index_arr1, index_arr2_broadcast]`, 由于索引数组的个数和被索引数组的维度不同, 被索引数组中未使用的维度的形状为最后一个`5`, 需要拼接, 即`(2, 2)`和`(, 5)`拼接, 所以返回数组的形状为`(2, 2, 5)`. 

### 布尔数组索引

选择对象为一个或者多个布尔索引数组的索引称为布尔数组索引. 

???+ note "笔记"

    索引数组, 被索引数组和选择对象:

    ???+ example "例子"

        ```
        >>> x = np.array([[1, 2, 3], 
                          [4, 5, 6], 
                          [7, 8, 9]])
        >>> index_arr = np.array([[True, False, True], 
                                  [False, True, False], 
                                  [True, False, True]])
        >>> x[index_arr]
        array([1, 3, 5, 7, 9])
        ```

        - `x[obj]`中的`obj`作为一个整体被称为索引对象
        - `index_arr`为索引数组
        - `x`为被索引数组

可以将布尔索引数组转换为[整数索引数组](#整数数组索引), 然后用整数数组索引的[思想](#整数数组索引的机理)做布尔数组索引.

`[布尔索引数组].nonzero()`会返回一个包含整数索引数组的元组(整数索引数组的个数为`[布尔索引数组].ndim`). 这个整数索引数组会显示布尔索引数组中为`True`的元素的索引.

???+ tip "Tip"

    - `[arr].ndim`返回`[arr]`的维度.

        ???+ example "例子"

            ```
            >>> x = np.array([1, 2, 3])
            >>> x.ndim
            1
            >>> y = np.zeros((2, 3, 4))
            >>> y.ndim
            3
            ```

???+ example "例子"

    === "例子1"

        ```
        >>> x = np.array([1, 2, 3, 4, 5])
        >>> index_arr = np.array([True, False, True, False, True])
        >>> x[index_arr]
        array([1, 3, 5])
        >>> index_arr = index_arr.nonzero()
        >>> index_arr
        (array([0, 2, 4]),)
        >>> x[index_arr]
        array([1, 3, 5])
        ```

    === "例子2"

        ```
        >>> x = np.array([[1, 2, 3], 
                          [4, 5, 6], 
                          [7, 8, 9]])
        >>> index_arr1 = np.array([True, False, True])
        >>> index_arr2 = np.array([False, True, False])
        >>> x[index_arr1, index_arr2]
        array([2, 8])
        >>> index_arr1 = index_arr1.nonzero()
        >>> index_arr2 = index_arr2.nonzero()
        >>> index_arr1
        (array([0, 2]),)
        >>> index_arr2
        (array([1]),)
        >>> x[index_arr1, index_arr2]
        array([[2, 8]])
        ```

    可以看到, 使用`[布尔索引数组].nonzero()`转化为整数索引数组之后, 效果一摸一样.



[^1]: Indexing on ndarrays—NumPy v2.0 Manual. (n.d.). Retrieved June 21, 2024, from https://numpy.org/doc/stable/user/basics.indexing.html
[^2]: 理解python索引和切片 · Issue #15 · qiwihui/blog. (n.d.). GitHub. Retrieved June 21, 2024, from https://github.com/qiwihui/blog/issues/15