---
title: 异步
icon: material/sync
comments: true
---

## 协程 {#协程}

在传统线程的执行过程中, 函数都是顺序执行的. 而协程, Coroutine, 则不同, 在执行过程中, 其函数内部可以产生中断, 转而执行别的函数, 在适当的时候再返回来接着执行. 所以说, 这是一种并发执行, 和多线程差不多, 多线程也是并发执行, 而不是并行执行(由于[GIL锁](/基础/线程/#CPython中线程无法并行)的存在).

### 协程的优势

协程和多线程比的优势就是: 

- 极高的执行效率: 在线程内部不涉及切换, 没有开销
- 不需要多线程锁: 只有一个线程, 不存在像多线程那样子线程同时读写共享资源的冲突, 但是存在对其他进程之间的共享资源的读写冲突

### 协程实现并行

在单个线程内的协程是并发的, 可以用[多进程](/基础/线程/#多线程)+协程实现利用多核心CPU. 

### 协程的实现方式

可以由多种方式实现协程, 其中主要包括[生成器](/基础/容器/#生成器)和`asyncio`模块提供的`async/await`关键字.

## 生成器实现协程

[生成器](/基础/容器/#生成器)是一种强大的工具, 允许你通过惰性方式生成序列. 通常, 我们用生成器对象的`next()`方法获取下一个值. 然而, 生成器对象还有`send()`方法, 不仅可以恢复生成器的执行, 还可以向生成器对象发送一个值, 该值会被`yield`表示式接受并作为返回值.

???+ example "例子"

    定义: 

    ```py
    def echo_generator():
    while True:
        received = yield
        print(f'Received: {received}')

    gen = echo_generator()
    next(gen)
    gen.send('Hello')
    gen.send('World')
    ```

    执行: 

    ```
    $ python main.py
    Received: Hello
    Received: World
    ```

    1. 得到了一个生成器对象`gen`
    2. `next(gen)`用于启动生成器, 直到执行到`yield`中断
    3. `gen.send('Hello')`, 执行赋值操作`received = 'Hello'`, 打印, 直到执行到`yield`中断
    4. `gen.send('World')`, 执行赋值操作`received = 'World'`, 打印, 直到执行到`yield`中断

现在来看由生成器实现的一个协程: 

???+ example "例子"

    定义: 

    ```py
    def consumer():
        v = ''
        while True:
            u = yield v
            if not u:
                return
            print('[CONSUMER] Consuming %s...' % u)
            v = '200 OK'

    def produce(c):
        c.send(None)
        n = 0
        while n < 5:
            n = n + 1
            print('[PRODUCER] Producing %s...' % n)
            r = c.send(n)
            print('[PRODUCER] Consumer return: %s' % r)
        c.close()

    c = consumer()
    produce(c)
    ```

    执行: 

    ```
    $ python main.py
    [PRODUCER] Producing 1...
    [CONSUMER] Consuming 1...
    [PRODUCER] Consumer return: 200 OK
    [PRODUCER] Producing 2...
    [CONSUMER] Consuming 2...
    [PRODUCER] Consumer return: 200 OK
    [PRODUCER] Producing 3...
    [CONSUMER] Consuming 3...
    [PRODUCER] Consumer return: 200 OK
    [PRODUCER] Producing 4...
    [CONSUMER] Consuming 4...
    [PRODUCER] Consumer return: 200 OK
    [PRODUCER] Producing 5...
    [CONSUMER] Consuming 5...
    [PRODUCER] Consumer return: 200 OK
    ```

    1. 得到了一个生成器对象`c`, 将其传入`produce()`函数中
    2. `c.send(None)`用于启动生成器, 无法执行赋值操作`u = None`, 直到执行到`yield ''`中断, 返回给生产者`''`
    3. `c.send(1)`, 执行赋值操作`u = 1`, 消费者消费, 直到执行`yield '200 OK'`中断, 返回给生产者`'200 OK'`
    4. `c.send(2)`, 执行赋值操作`u = 2`, 消费者消费, 直到执行`yield '200 OK'`中断, 返回给生产者`'200 OK'`
    5. 继续下一轮循环

    ???+ tip "Tip"

        每次执行`r = c.send([value])`时, `u = yield v`语句的执行过程如下: 

        1. 上次操作只执行了`yield v`但是没有执行赋值
        2. 从中断点继续执行另一半赋值`u = [value]`
        3. 执行逻辑
        4. 执行`u = yield v`中的`yield v`部分并中断, 不执行赋值
        5. `r = v`

    ???+ note "笔记"

        传统的生产者-消费者模型是一个线程生产, 一个线程消费, 通过锁控制, 一不小心可能导致死锁. 如果改用协程, 生产者生产之后, 直接通过生成器对象的`send()`函数将物品转移给消费者消费, 待消费者消费完毕后, 切换到生产者继续生产, 效率极高.
