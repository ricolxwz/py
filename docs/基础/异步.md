---
title: 异步
icon: material/sync
comments: true
---

## 协程 {#协程}

在传统线程的执行过程中, 函数都是顺序执行的. 而协程, Coroutine, 则不同, 在执行过程中, 其函数内部可以产生中断, 转而执行别的函数, 在适当的时候再返回来接着执行. 所以说, 这是一种并发执行, 和多线程差不多, 多线程也是并发执行, 而不是并行执行(由于[GIL锁](/基础/线程/#CPython中线程无法并行)的存在).

### 协程的优势

协程和多线程比的优势就是: 

- 极高的执行效率: 在线程内部不涉及切换, 没有开销
- 不需要多线程锁: 只有一个线程, 不存在像多线程那样子线程同时读写共享资源的冲突, 但是存在对其他进程之间的共享资源的读写冲突

### 协程实现并行

在单个线程内的协程是并发的, 可以用[多进程](/基础/线程/#多线程)+协程实现利用多核心CPU. 

### 协程的实现方式

可以由多种方式实现协程, 其中主要包括[生成器](/基础/容器/#生成器)和`asyncio`模块提供的`async/await`关键字.

## 生成器实现协程

[生成器](/基础/容器/#生成器)是一种强大的工具, 允许你通过惰性方式生成序列. 通常, 我们用生成器对象的`next()`方法获取下一个值. 然而, 生成器对象还有`send()`方法, 不仅可以恢复生成器的执行, 还可以向生成器对象发送一个值, 该值会被`yield`表示式接受并作为返回值.

???+ example "例子"

    定义: 

    ```py
    def echo_generator():
    while True:
        received = yield
        print(f'Received: {received}')

    gen = echo_generator()
    next(gen)
    gen.send('Hello')
    gen.send('World')
    ```

    执行: 

    ```
    $ python main.py
    Received: Hello
    Received: World
    ```

    `next(gen)`用于启动生成器, 到达第一个`yield`所在的位置. 或者我们也可以用`gen.send(None)`启动生成器. `gen.send('Hello')`恢复生成器的执行, 发送`Hello`作为值, `yield`接收到之后作为返回值返回给`received`. 执行完成之后会到`yield`等待下一个`send()`.