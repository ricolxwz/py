---
title: 对象
icon: material/code-braces
---

## 访问限制

在外部, 如果未加限制, 我们可以自由地修改一个实例的属性. 如果要让内部属性不被外部直接访问, 我们可以在属性的名称前面加上两个下划线`__`. 这样属性就变成了一个"私有"属性, 外部"无法"访问. 

???+ example "例子"

    定义类: 

    ```py
    class Student(object):

        def __init__(self, name, score):
            self.__name = name
            self.__score = score
    ```

    使用类: 

    ```
    >>> wenzexu = Student('Wenze Xu', 18)
    >>> wenzexu.__name
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    AttributeError: 'Student' object has no attribute '__name'
    ```

???+ tip "Tip"

    双下划线开头的变量不是真的无法从外面访问, 无法访问这样的变量是因为解释器将`__[var]`变成了`_[class]__[var]`, 我们仍然可以通过`_[class]__[var]`的形式访问`__[var]`变量. 

    ???+ example "例子"

        ```
        >>> wenzexu._Student__name
        Wenze Xu
        ```

???+ note "笔记"

    - 变量名类似`__[var]__`的是特殊变量, 是可以直接访问的, 不是私有变量
    - 变量名类似`_[var]`的, 是可以被外部访问的, 但是按照规定, 虽然可以被访问, 但是请将这种变量视为私有变量
    - 变量名类似`__[var]`的, 是"无法"被外部访问的

???+ warning "注意"

    请不要从外部直接设置私有变量, 否则设置的不是那个私有变量, 设置的是另一个变量.

    ???+ example "例子"

        ```
        >>> wenzexu = Student('Wenze Xu', 18)
        >>> wenzexu.get_name()
        Wenze Xu
        >>> wenzexu.__name = "Xingze Xu"
        >>> wenzexu.__name
        Xingze Xu
        >>> wenzexu.get_name()
        Wenze Xu
        ```

        表面上看, 外部代码修改了`__name`变量, 但是内部的`__name`已经被解释器自动改成了`_Student__name`, 而外部代码给`wenzexu`实例新增了一个`__name`变量.

### getter和setter

如果要访问或者修改这个"私有"属性, 可以使用getter和setter. 

???+ example "例子"

    ```py
    class Student(object):
        ...

        def get_name(self):
            return self.__name

        def get_score(self):
            return self.__score
    ```

???+ note "笔记"

    getter和setter的优势是你可以自定义在读取或者写入属性时发生的操作, 比如参数检查, 避免传入无效参数等等...

[^1]: 访问限制. (n.d.). Retrieved June 14, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017496679217440