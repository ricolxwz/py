---
title: 对象
icon: material/code-braces
---

## 访问限制

在外部, 如果未加限制, 我们可以自由地修改一个实例的属性. 如果要让内部属性不被外部直接访问, 我们可以在属性的名称前面加上两个下划线`__`. 这样属性就变成了一个"私有"属性, 外部"无法"访问. 

???+ example "例子"

    定义类: 

    ```py
    class Student(object):

        def __init__(self, name, score):
            self.__name = name
            self.__score = score
    ```

    使用类: 

    ```
    >>> wenzexu = Student('Wenze Xu', 18)
    >>> wenzexu.__name
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    AttributeError: 'Student' object has no attribute '__name'
    ```

???+ tip "Tip"

    双下划线开头的变量不是真的无法从外面访问, 无法访问这样的变量是因为解释器将`__[var]`变成了`_[class]__[var]`, 我们仍然可以通过`_[class]__[var]`的形式访问`__[var]`变量. 

    ???+ example "例子"

        ```
        >>> wenzexu._Student__name
        Wenze Xu
        ```

???+ note "笔记"

    - 变量名类似`__[var]__`的是特殊变量, 是可以直接访问的, 不是私有变量
    - 变量名类似`_[var]`的, 是可以被外部访问的, 但是按照规定, 虽然可以被访问, 但是请将这种变量视为私有变量
    - 变量名类似`__[var]`的, 是"无法"被外部访问的

???+ warning "注意"

    请不要从外部直接设置私有变量, 否则设置的不是那个私有变量, 设置的是另一个变量.

    ???+ example "例子"

        ```
        >>> wenzexu = Student('Wenze Xu', 18)
        >>> wenzexu.get_name()
        Wenze Xu
        >>> wenzexu.__name = "Xingze Xu"
        >>> wenzexu.__name
        Xingze Xu
        >>> wenzexu.get_name()
        Wenze Xu
        ```

        表面上看, 外部代码修改了`__name`变量, 但是内部的`__name`已经被解释器自动改成了`_Student__name`, 而外部代码给`wenzexu`实例新增了一个`__name`变量.

### getter和setter

如果要访问或者修改这个"私有"属性, 可以使用getter和setter. 

???+ example "例子"

    ```py
    class Student(object):
        ...

        def get_name(self):
            return self.__name

        def get_score(self):
            return self.__score
    ```

???+ note "笔记"

    getter和setter的优势是你可以自定义在读取或者写入属性时发生的操作, 比如参数检查, 避免传入无效参数等等...

## 绑定限制 {#绑定限制}

### 动态绑定的灵活性

正常情况下, 我们创建了一个实例之后, 我们可以给该实例绑定任何属性和方法, 这就是动态语言的灵活性.

???+ example "例子"

    定义类:

    ```py
    class Student(object):
        pass
    ```

    尝试绑定属性: 

    ```
    >>> s = Student()
    >>> s.name = "wenzexu"
    >>> print(s.name)
    wenzexu
    ```

    尝试绑定方法: 

    ```
    >>> def set_age(self, age):
    ...     self.age = age
    ...
    >>> from types import MethodType
    >>> s.set_age = MethodType(set_age, s)
    >>> s.set_age(18)
    >>> s.age
    18
    ```

    ???+ warning "注意"

        给实例绑定一个方法, 对另一个实例是没有作用的

        ???+ example "例子"

            ```
            >>> s2 = Student()
            >>> s2.set_age(100)
            Traceback (most recent call last):
                File "<stdin>", line 1, in <module>
            AttributeError: 'Student' object has no attribute 'set_age'
            ```
        
        ???+ tip "Tip"

            为了给所有实例都绑定方法, 可以给类绑定方法

            ???+ example "例子"

                定义方法:  

                ```
                >>> def set_score(self, score):
                ...     self.score = score
                ... 
                >>> Student.set_score = set_score
                ```
            
                使用方法: 

                ```
                >>> s.set_score(100)
                >>> s.score
                100
                >>> s2.set_score(99)
                >>> s2.score
                99
                ```
            
            通常情况下, 我们不需要这么干, 我们可以直接在类里面定义类方法, 但是这样做是显示Python这门语言的灵活性. 
    
### `__slots__` {#slots}

如果我们要限制实例的属性该怎么办? 在定义类的时候, 可以用`__slot__`这个特殊类属性来限制实例能够添加的属性.

???+ example "例子"

    定义类: 

    ```py
    class Student(object):
        __slot__ = ('name', 'age')
    ```

    尝试绑定属性:

    ```
    >>> s = Student
    >>> s.name = "wenzexu"
    >>> s.age = 18
    >>> s.score = 99
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    AttributeError: 'Student' object has no attribute 'score'
    ```

    由于`score`不在`__slot__`当中, 所以无法绑定`score`属性. 

???+ warning "注意"

    `__slot__`定义的属性仅对当前的实例起作用, 对继承的字类是不起作用的. 

    ???+ example "例子"

        ```
        >>> class GraduateStudent(Student):
        ...     pass
        ...
        >>> g = GraduateStudent()
        >>> g.score = 999
        ```

    除非在字类的定义中也定义`__slots__`, 这样, 字类实例允许定义的属性是自身的`__slots__`加上父类的`__slots__`.

## `@property`

前面讲到, 我们可以用getter, setter方法进行参数检查, 格式化输出... 这种方法略显复杂, 那么如何用类似属性这样的方式来访问/修改实例的属性呢? 我们可以用装饰器的方法, 这里用到的装饰器是内置的`@property`, 把一个getter方法变成以属性的方式输出, 只需要添加`@property`; 把一个setter方法变成以属性的方式赋值, 只需要添加`@[property].setter`.

???+ example "例子"

    定义类:

    ```py
    class Student(object):

        @property
        def score(self):
            return self._score

        @score.setter
        def score(self, value):
            if not isinstance(value, int):
                raise ValueError('score must be an integer!')
            if value < 0 or value > 100:
                raise ValueError('score must between 0 ~ 100!')
            self._score = value
    ```

    以属性的方式读取/修改实例属性: 

    ```
    >>> s = Student()
    >>> s.score = 60
    >>> s.score
    60
    >>> s.score = 9999
    Traceback (most recent call last):
        ...
    ValueError: score must between 0 ~ 100!
    ```

???+ tip "Tip"

    如果只定义getter方法, 不定义setter方法就是一个只读属性.

    ???+ example "例子"

        ```py
        class Student(object):

            @property
            def age(self):
                return 2015 - self._birth
        ```

???+ warning "注意"

    属性的方法名不要和实例的变量重名.

    ???+ example "例子"

        ```py
        class Student(object):

            @property
            def birth(self):
                return self.birth
        ```

        调用`s.birth`的时候, 首先转化为方法调用, 在执行`return self.birth`的时候, 又转化为方法调用, 造成死循环, 最终导致栈溢出.

## 多重继承

一个类继承自不止一个父类, 这叫做多重继承. 

???+ example "例子"

    ```py
    class Animal(object):
        pass

    class Mammal(Animal):
        pass

    class Runnable(object):
        def run(self):
            print("Running...")

    class Jumpable(object):
        def jump(self):
            print("Jumping...")

    class Dog(Mammal, Runnable, Jumpable):
        pass
    ```

    `Dog`类通过多重继承, 获得了`Mammal`和`Runnable`类的所有功能: 

    ```
    >>> d = Dog()
    >>> d.run()
    Running...
    >>> d.jump()
    Jumping...
    ```

## 定制类 {#定制类}

在类的一些属性中有一些属性/方法是形如`__[property]__`的, 这种属性/方法可以帮助我们定制一个类, 如[`__slots__`](#slots)可以进行[绑定限制](#绑定限制). 

### `__str__`

`__str__`特殊方法用于打印实例. 

???+ example "例子"

    ```
    >>> class Student(object):
    ...     def __init__(self, name):
    ...         self.name = name
    ...     def __str__(self):
    ...         return 'Student object (name: %s)' % self.name
    >>> print(Student('wenzexu'))
    Student object (name: wenzexu)
    ```

???+ tip "Tip"

    单独定义一个`__str__`方法后, 直接输出变量输出的还是一串不好看的字符串, 因为直接显示变量调用的是`__repr__`方法. 两者的区别是`__str__`方法返回的是用户看到的字符串, 而`__repr__`方法返回的是开发者看到的字符串. 
    
    ???+ example "例子"

        ```
        >>> s = Student('wenzexu')
        >>> s
        <__main__.Student object at 0x109afb310>
        ```

     这可以通过定义`__repr__`方法解决. 

     ???+ example "例子"

        定义类:

        ```py
        class Student(object):
            def __init__(self, name):
                self.name = name
            def __str__(self):
                return 'Student object (name=%s)' % self.name
            __repr__ = __str__
        ```

        打印类:

        ```
        >>> print(Student('wenzexu'))
        Student object (name: wenzexu) 
        >>> s = Student('wenzexu')
        >>> s
        Student object (name: wenzexu) 
        ```

### `__iter__` {#iter}

`__iter__`特殊方法可以把一个实例变为[迭代器](/基础/容器/#迭代器). 该方法返回一个[迭代器](/基础/容器/#迭代器), 然后for循环就会不断调用该迭代对象的`__next__`方法拿到下一个值, 知道遇到`StopIteration`错误退出循环.

???+ example "例子"

    定义类: 

    ```py
    class Fib(object):
        def __init__(self):
            self.a, self.b = 0, 1

        def __iter__(self):
            return self

        def __next__(self):
            self.a, self.b = self.b, self.a + self.b
            if self.a > 100000:
                raise StopIteration()
            return self.a
    ```

    把一个实例作用于for循环:

    ```
    >>> for n in Fib():
    ...     print(n)
    ...
    1
    1
    2
    3
    5
    ...
    46368
    75025
    ```


[^1]: 访问限制. (n.d.). Retrieved June 14, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017496679217440
[^2]: 使用__slots__. (n.d.). Retrieved June 14, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017501655757856
[^3]: 多重继承. (n.d.). Retrieved June 14, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017502939956896
[^4]: 使用@property. (n.d.). Retrieved June 14, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208