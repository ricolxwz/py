---
title: PVM
icon: material/slot-machine
comments: false
---

## 垃圾回收

垃圾回收, Garbage Collection, 简称GC是一种自动的内存管理机制, 旨在识别和清理不在被程序访问的内存, 从而释放资源防止内存泄露. 垃圾回收的基本原理是, 当程序不再需要某个对象的时候, 自动回收该对象占用的内存, 以便后续使用.

虽然GC简化了内存管理, 但是它可能引入性能开销, 尤其是在垃圾回收的时候, 可能导致程序的暂停(Stop-The-World, STW). 不同语言的GC实现会影响性能表现, 开发者需要根据应用场景选择合适的GC策略. 

非GC语言, 如C, C++等要求程序员手动管理内存, 包括分配和释放. 这种方式提供了更大的灵活性和控制权, 但是也增加了出错的风险, 如内存泄露和悬空指针等问题. 由于程序员可以精确控制内存的分配和释放, 非GC语言在性能上通常更具有优势, 适合对性能要求极高的应用(如游戏开发, 系统编程等).

Python的底层垃圾回收算法主要有三种: 引用计数, 标记-清除和分代回收. 主要以引用计数为主, 标记-清除和分代回收为辅. 

## 引用计数

引用计数的原理比较简单, 每个对象都有一个整形的引用计数属性. 用于记录对象被引用的次数. 例如对象A, 如果有一个对象引用了A, 则A的引用计数+1. 当引用删除的时候, A的引用计数-1. 当A的引用计数为0的时候, 即表示对象A不可能再被利用, 直接回收.

???+ example "例子"

    如下列代码:

    ```py
    import sys

    class A():
        def __init__(self):
            pass
    
    a = A()
    print(sys.getrefcount(a))
    ```

    运行上述代码, 得到输出结果为2.

### 引用计数+1的条件

- 对象被创建, 如`A()`
- 对象被引用, 如`a=A()`
- 对象作为函数的参数, 如`func(a)`
- 对象作为容器的元素, 如`arr=[a, a]`

### 引用计数-1的条件

- 对象被显式销毁, 如`del a`
- 变量被重新赋予新的对象, 如`a=0`
- 对象离开它的作用域, 如`func`函数执行完毕时, 当中的局部变量
- 对象所在的容器被销毁, 或从容器中删除对象

### 
