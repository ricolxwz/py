---
title: 线程
icon: material/spider-thread
comments: true
---

## 多进程

在Python中, 我们可以利用多种方法在父进程中创建子进程. 当我们用`python`命令执行了一个`.py`文件的时候, 就创建了一个进程, 在这个`.py`文件中, 我们通过一些手段又创建了一些进程, 这些进程就被称为子进程. 

???+ tip "Tip"

    - 父进程是创建子进程的进程
    - 子进程继承了父进程的环境变量, 但是无法直接访问父进程的变量、函数或者其他资源

        ??? example "例子"

            定义:

            ```py
            import os
            import subprocess

            # 设置父进程的环境变量
            os.environ['MY_VAR'] = 'Hello from parent process!'

            # 启动子进程，运行命令 'printenv MY_VAR' 以打印环境变量 MY_VAR 的值
            process = subprocess.Popen(['printenv', 'MY_VAR'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            # 获取子进程的输出
            stdout, stderr = process.communicate()

            # 打印子进程的输出
            print('STDOUT:', stdout) 
            ```

            输出:

            ```
            $ python main.py
            Hello from parent process!
            ```
                       
    - 如果子进程需要与父进程共享某些数据, 可以使用各种进程间通信机制, 如管道、队列、共享内存等
    - 子进程有自己独立的地址空间, 文件描述符表, 栈等资源

### `os`模块

`os`模块的`fork()`函数适用于Unix/Linux系统的低级进程创建, 直接调用系统的`fork()`接口, 适用于简单的子进程创建, 但是不提供高级的通信和同步机制. 调用`os.fork()`函数, 会返回两次, 因为操作系统把当前进程(父进程)复制了一份(子进程), 然后, 分别在父进程和子进程内返回. 之后, 父进程和子进程都会执行后面的代码. 

子进程永远返回0, 而父进程返回子进程的pid. 

???+ tip "Tip"

    `os.getpid()`函数可以获取当前进程的pid. `os.getppid()`函数可以获取当前进程的父进程的pid. 

???+ example "例子"

    定义: 

    ```py
    import os

    print('Process (%s) start...' % os.getpid())
    pid = os.fork()
    if pid == 0:
        print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))
    else:
        print('I (%s) just created a child process (%s).' % (os.getpid(), pid))
    ```

    运行:

    ```
    $ python main.py
    Process (876) start...
    I (876) just created a child process (877).
    I am child process (877) and my parent is 876.
    ```

    ???+ warning "注意"

        Windows没有提供`fork()`接口, 所以上述代码在Windows下无法运行.

### `subprocess`模块

`subprocess`模块适用于启动和管理外部命令行子进程, 能够和外部命令行子进程通过`communicate()`函数实现进程通信, 提供了发出`stdin`和接收`stdout`, `stderr`的功能. 其中的`Popen()`函数用于返回一个子进程对象.

???+ example "例子"

    定义:

    ```py
    import subprocess

    print('$ nslookup')
    p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
    print(output.decode('utf-8'))
    print('Exit code:', p.returncode)
    ```

    上述代码相当于在命令行执行命令`nslookup`然后手动输入:

    ```
    set q=mx
    python.org
    exit
    ```

    运行: 

    ```
    $ nslookup
    Server:		192.168.19.4
    Address:	192.168.19.4#53

    Non-authoritative answer:
    python.org	mail exchanger = 50 mail.python.org.

    Authoritative answers can be found from:
    mail.python.org	internet address = 82.94.164.166
    mail.python.org	has AAAA address 2001:888:2000:d::a6


    Exit code: 0
    ```

    ???+ tip "Tip"

        `[subprocess_instance].communicate()`方法是一种父进程和子进程间的进程间通信方式, 它是阻塞的, 意味着父进程会等待子进程完成之后才继续执行. 通信时一次性的, 即父进程发送数据到子进程, 然后读取子进程的输出, 不能持续进行双向通信, 适用于简单的父进程和子进程之间的进程间通信.


### `multiprocessing`模块 {#multiprocessing模块}

`multiprocessing`模块适用于并行处理和多进程编程, 提供了丰富的进程间通信和同步机制, 支持跨平台. 其中的`Process`类能够用于创建子进程对象.

???+ example "例子"

    定义: 

    ```py
    from multiprocessing import Process
    import os

    # 子进程要执行的代码
    def run_proc(name):
        print('Run child process %s (%s)...' % (name, os.getpid()))

    if __name__=='__main__':
        print('Parent process %s.' % os.getpid())
        p = Process(target=run_proc, args=('test',))
        print('Child process will start.')
        p.start()
        p.join()
        print('Child process end.')
    ```

    运行: 

    ```
    Parent process 928.
    Child process will start.
    Run child process test (929)...
    Process end.
    ```

    通过`[process].start()`启动子进程, 运行的代码在`run_proc`中. 

    ???+ note "笔记"

        `[process].join()`用于阻塞主进程, 直到子进程执行完毕.

        ???+ example "例子"

            ```py
            import multiprocessing
            import time

            def worker(number):
                print(f"Worker {number} started")
                time.sleep(2)
                print(f"Worker {number} finished")

            if __name__ == "__main__":
                processes = []
                for i in range(4):  # 创建4个子进程
                    process = multiprocessing.Process(target=worker, args=(i,))
                    processes.append(process)
                    process.start()

                for process in processes:
                    process.join()  # 等待所有子进程完成

                print("All workers completed")
            ```

            上述的例子中, 创建了4个子进程, 每个子进程执行`worker`函数, 如果任务都在主进程中顺序执行, 总共需要8秒完成. 而使用多进程同时执行4个任务, 只需要大约2秒的即可完成所有任务. `process.join()`函数用于阻塞当前的主进程, 当子进程全部执行完之后, 才打印"All workers completed".

            当然上述的代码还可以优化成使用[进程池](#进程池). 

### 进程池 {#进程池}

进程池由[multiprocessing模块](#multiprocessing模块)的`Pool`类提供支持.

???+ example "例子"

    定义:

    ```py
    from multiprocessing import Pool
    import os, time, random

    def long_time_task(name):
        print('Run task %s (%s)...' % (name, os.getpid()))
        start = time.time()
        time.sleep(random.random() * 3)
        end = time.time()
        print('Task %s runs %0.2f seconds.' % (name, (end - start)))

    if __name__=='__main__':
        print('Parent process %s.' % os.getpid())
        p = Pool(4)
        for i in range(5):
            p.apply_async(long_time_task, args=(i,))
        print('Waiting for all subprocesses done...')
        p.close()
        p.join()
        print('All subprocesses done.')
    ```

    运行: 

    ```
    $ python main.py
    Parent process 669.
    Waiting for all subprocesses done...
    Run task 0 (671)...
    Run task 1 (672)...
    Run task 2 (673)...
    Run task 3 (674)...
    Task 2 runs 0.14 seconds.
    Run task 4 (673)...
    Task 1 runs 0.27 seconds.
    Task 3 runs 0.86 seconds.
    Task 0 runs 1.41 seconds.
    Task 4 runs 1.91 seconds.
    All subprocesses done.
    ```

    ???+ tip "Tip"
    
        `[pool_instance].apply_async()`用于提交任务, 任务是否立即被执行取决于当前进程池中工人的数量, 即进程池对象被创建时的参数`Pool([worker_number])`, 默认的大小是当前电脑CPU的核心数量. 

        ???+ example "例子"

            如在上述的例子中, 我们定义了进程池中工人的数量是4个, 那么最多同时只能执行4个任务, 任务0, 1, 2, 3是立即执行的, 而任务4是等待前面某个任务执行完成之后才执行. 如果没有明确工人的数量, 那么默认是CPU的核心数量, 比如说8核处理器, 那么至少提交9个任务才会看到上面的等待效果.

### 进程间通信

队列式进程间通信由[multiprocessing模块](#multiprocessing模块)的`Queue`类提供支持, 此外还有管道式进程间通信, 这里不会详细介绍.

???+ example "例子"

    定义:

    ```py
    from multiprocessing import Process, Queue
    import os, time, random

    # 写数据进程执行的代码:
    def write(q):
        print('Process to write: %s' % os.getpid())
        for value in ['A', 'B', 'C']:
            print('Put %s to queue...' % value)
            q.put(value)
            time.sleep(random.random())

    # 读数据进程执行的代码:
    def read(q):
        print('Process to read: %s' % os.getpid())
        while True:
            value = q.get(True)
            print('Get %s from queue.' % value)

    if __name__=='__main__':
        # 父进程创建Queue，并传给各个子进程：
        q = Queue()
        pw = Process(target=write, args=(q,))
        pr = Process(target=read, args=(q,))
        # 启动子进程pw，写入:
        pw.start()
        # 启动子进程pr，读取:
        pr.start()
        # 等待pw结束:
        pw.join()
        # pr进程里是死循环，无法等待其结束，只能强行终止:
        pr.terminate()
    ```

    运行: 

    ```
    $ python main.py
    Process to write: 50563
    Put A to queue...
    Process to read: 50564
    Get A from queue.
    Put B to queue...
    Get B from queue.
    Put C to queue...
    Get C from queue.
    ```

    上述的例子中, 一个子进程用于向队列里面写数据, 另一个子进程用于由队列里面读数据.

[^1]: 多进程. (n.d.). Retrieved June 16, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064