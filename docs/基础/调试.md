---
title: 调试
icon: material/test-tube
comments: true
---

## 错误

### 捕获错误

捕获错误用到的是`try...except...else...finally`的结构.

???+ example "例子"

    ```py
    try:
        print('try...')
        r = 10 / int('2')
        print('result:', r)
    except ValueError as e:
        print('ValueError:', e)
    except ZeroDivisionError as e:
        print('ZeroDivisionError:', e)
    else:
        print('no error!')
    finally:
        print('finally...')
    print('END')
    ```

???+ tip "Tip"

    - 错误是类, 所有的错误类都继承自`BaseException`
    - `except`不但捕获该类型的错误, 还把其子类都一网打尽
    - 可以跨越多层捕获错误

        ???+ example "例子"

            ```py
            def foo(s):
                return 10 / int(s)

            def bar(s):
                return foo(s) * 2

            def main():
                try:
                    bar('0')
                except Exception as e:
                    print('Error:', e)
                finally:
                    print('finally...')
            ```

    - 调用栈: 如果错误没有被捕获, 会一直向上抛, 最后被捕获

        ???+ example "例子"

            定义: 

            ```py
            def foo(s):
                return 10 / int(s)

            def bar(s):
                return foo(s) * 2

            def main():
                bar('0')

            main()
            ```

            执行: 

            ```
            $ python main.py
            Traceback (most recent call last):
                File "err.py", line 11, in <module>
                    main()
                File "err.py", line 9, in main
                    bar('0')
                File "err.py", line 6, in bar
                    return foo(s) * 2
                File "err.py", line 3, in foo
                    return 10 / int(s)
            ZeroDivisionError: division by zero
            ```

### 记录错误

如果不捕获错误, 解释器会打印出错误, 但程序被结束了. 如果捕获了错误, 可以用`logging`模块让解释器也按照原来的格式打印出错误.

???+ example "例子"

    定义: 

    ```py
    import logging

    def foo(s):
        return 10 / int(s)

    def bar(s):
        return foo(s) * 2

    def main():
        try:
            bar('0')
        except Exception as e:
            logging.exception(e)

    main()
    print('END')
    ```

    执行:

    ```
    $ python main.py
    ERROR:root:division by zero
    Traceback (most recent call last):
    File "err_logging.py", line 13, in main
        bar('0')
    File "err_logging.py", line 9, in bar
        return foo(s) * 2
    File "err_logging.py", line 6, in foo
        return 10 / int(s)
    ZeroDivisionError: division by zero
    END
    ```

### 抛出错误

捕获错误其实就是捕获到对应错误类的一个对象, 因此错误是有意创建并抛出的. 内置函数会抛出很多类型的错误对象, 我们也可以编写抛出的错误对象. 要抛出错误, 首先, 定义一个错误的类, 选择好继承关系, 然后用`raise`语句抛出一个错误的对象: 

???+ example "例子"

    定义: 

    ```py
    class FooError(ValueError):
        pass

    def foo(s):
        n = int(s)
        if n==0:
            raise FooError('invalid value: %s' % s)
        return 10 / n

    foo('0')
    ```

    执行: 

    ```
    $ python main.py
    Traceback (most recent call last):
    File "err_throw.py", line 11, in <module>
        foo('0')
    File "err_throw.py", line 8, in foo
        raise FooError('invalid value: %s' % s)
    __main__.FooError: invalid value: 0
    ```

#### 错误传播

???+ example "例子"

    定义: 

    ```py
    def foo(s):
        n = int(s)
        if n == 0:
            raise ValueError('invalid value: %s' % s)
        return 10 / n

    def bar():
        try:
            foo('0')
        except ValueError as e:
            print('ValueError caught in bar()')
            raise

    def baz():
        try:
            bar()
        except ValueError as e:
            print('ValueError caught in baz()')

    baz()
    ```

    执行: 

    ```
    $ python main.py
    ValueError caught in bar()
    ValueError caught in baz()
    ```

    在这个函数中, 我们已经捕获到了错误, 但是又把错误通过`raise`抛出去了. 这样做的目的是为了将原始异常的信息向上传播, 实现和调用栈相似的功能. 如果没有在`bar()`将错误抛出, 如: 

    ```py
    def foo(s):
        n = int(s)
        if n == 0:
            raise ValueError('invalid value: %s' % s)
        return 10 / n

    def bar():
        try:
            foo('0')
        except ValueError as e:
            print('ValueError caught in bar()')

    def baz():
        try:
            bar()
        except ValueError as e:
            print('ValueError caught in baz()')

    baz()
    ```

    执行: 

    ```
    $ python main.py
    ValueError caught in bar()
    ```

    `baz()`和函数是不知道`bar`函数中发生了异常的, 这样就无法实现调用栈的功能. 

## 调试

程序能一次性写对的概率很小, 我们需要知道出错的地方, 可以通过调试解决, 一般有5种方法: 

1. 打印变量
2. [`assert`](#断言)
3. [`logging`模块](#logging模块)
4. [`pdb`模块](#pdb模块)
5. IDE

### 断言 {#断言}

可以使用`assert`来判断表达式的结果是否和我们预期的相符. 如果相符, 则正常运行; 否则, 抛出`AssertionError`错误.

???+ example "例子"

    定义: 

    ```py
    def foo(s):
        n = int(s)
        assert n != 0, 'n is zero!'
        return 10 / n

    def main():
        foo('0')
    ```

    执行: 

    ```
    $ python main.py
    Traceback (most recent call last):
        ...
    AssertionError: n is zero!
    ```

    ???+ tip "Tip"

        启动Python解释器时可以用`-O`参数关闭断言, 关闭后, 所有的`assert`语句相当于`pass`.

        ???+ example "例子"

            ```
            $ python -O main.py
            Traceback (most recent call last):
                ...
            ZeroDivisionError: division by zero
            ```

### `logging`模块 {#logging模块}

与`assert`相比, `logging`不会抛出错误, 但是会输出一些信息. 

???+ example "例子"

    定义: 

    ```py
    import logging

    logging.basicConfig(level=logging.INFO)
    s = '0'
    n = int(s)
    logging.info('n = %d' % n)
    print(10 / n)
    ```

    执行: 

    ```
    $ python main.py
    INFO:root:n = 0
    Traceback (most recent call last):
    File "err.py", line 8, in <module>
        print(10 / n)
    ZeroDivisionError: division by zero
    ```

???+ tip "Tip"

    `logging`允许指定信息的级别, 有`logging.DEBUG`, `logging.INFO`, `logging.WARNING`, `logging.ERROR`几个级别, 当指定`level=logging.INFO`的时候, `logging.debug`就不起作用了. 同理, 指定`level=logging.WARNING`的时候, `logging.debug`和`logging.info`就不起作用了.

### `pdb`模块 {#pdb模块}

???+ example "例子"

    定义: 

    ```
    s = '0'
    n = int(s)
    print(10 / n)
    ```

    执行: 

    ```
    $ python -m pdb main.py
    ```

    启动之后: 

    - 输入`l`回车查看代码
    - 输入`n`回车单步执行代码
    - 输入`p [变量名]`查看变量
    - 输入`q`结束调试
    - 输入`c`继续运行

???+ tip "Tip"

    可以用`pdb.set_trace()`方法设置断点, pdb启动后会直接到断点所在的位置.

    ???+ example "例子"

        ```py
        import pdb

        s = '0'
        n = int(s)
        pdb.set_trace() # 运行到这里会自动暂停
        print(10 / n)
        ```

[^1]: 错误处理. (n.d.). Retrieved June 17, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017598873256736
[^2]: 调试. (n.d.). Retrieved June 17, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017602696742912
[^3]: 单元测试. (n.d.). Retrieved June 17, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017604210683936
[^4]: 文档测试. (n.d.). Retrieved June 17, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017605739507840