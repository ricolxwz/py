---
title: 调试
icon: material/test-tube
comments: true
---

## 错误

### 捕获错误

捕获错误用到的是`try...except...else...finally`的结构.

???+ example "例子"

    ```py
    try:
        print('try...')
        r = 10 / int('2')
        print('result:', r)
    except ValueError as e:
        print('ValueError:', e)
    except ZeroDivisionError as e:
        print('ZeroDivisionError:', e)
    else:
        print('no error!')
    finally:
        print('finally...')
    print('END')
    ```

???+ tip "Tip"

    - 错误是类, 所有的错误类都继承自`BaseException`
    - `except`不但捕获该类型的错误, 还把其子类都一网打尽
    - 可以跨越多层捕获错误

        ???+ example "例子"

            ```py
            def foo(s):
                return 10 / int(s)

            def bar(s):
                return foo(s) * 2

            def main():
                try:
                    bar('0')
                except Exception as e:
                    print('Error:', e)
                finally:
                    print('finally...')
            ```

    - 调用栈: 如果错误没有被捕获, 会一直向上抛, 最后被捕获

        ???+ example "例子"

            定义: 

            ```py
            def foo(s):
                return 10 / int(s)

            def bar(s):
                return foo(s) * 2

            def main():
                bar('0')

            main()
            ```

            执行: 

            ```
            $ python main.py
            Traceback (most recent call last):
                File "err.py", line 11, in <module>
                    main()
                File "err.py", line 9, in main
                    bar('0')
                File "err.py", line 6, in bar
                    return foo(s) * 2
                File "err.py", line 3, in foo
                    return 10 / int(s)
            ZeroDivisionError: division by zero
            ```

### 记录错误

如果不捕获错误, 解释器会打印出错误, 但程序被结束了. 如果捕获了错误, 可以用`logging`模块让解释器也按照原来的格式打印出错误.

???+ example "例子"

    定义: 

    ```py
    import logging

    def foo(s):
        return 10 / int(s)

    def bar(s):
        return foo(s) * 2

    def main():
        try:
            bar('0')
        except Exception as e:
            logging.exception(e)

    main()
    print('END')
    ```

    执行:

    ```
    $ python main.py
    ERROR:root:division by zero
    Traceback (most recent call last):
    File "err_logging.py", line 13, in main
        bar('0')
    File "err_logging.py", line 9, in bar
        return foo(s) * 2
    File "err_logging.py", line 6, in foo
        return 10 / int(s)
    ZeroDivisionError: division by zero
    END
    ```

### 抛出错误

捕获错误其实就是捕获到对应错误类的一个对象, 因此错误是有意创建并抛出的. 内置函数会抛出很多类型的错误对象, 我们也可以编写抛出的错误对象. 要抛出错误, 首先, 定义一个错误的类, 选择好继承关系, 然后用`raise`语句抛出一个错误的对象: 

???+ example "例子"

    定义: 

    ```py
    class FooError(ValueError):
        pass

    def foo(s):
        n = int(s)
        if n==0:
            raise FooError('invalid value: %s' % s)
        return 10 / n

    foo('0')
    ```

    执行: 

    ```
    $ python main.py
    Traceback (most recent call last):
    File "err_throw.py", line 11, in <module>
        foo('0')
    File "err_throw.py", line 8, in foo
        raise FooError('invalid value: %s' % s)
    __main__.FooError: invalid value: 0
    ```

#### 错误传播

???+ example "例子"

    定义: 

    ```py
    def foo(s):
        n = int(s)
        if n == 0:
            raise ValueError('invalid value: %s' % s)
        return 10 / n

    def bar():
        try:
            foo('0')
        except ValueError as e:
            print('ValueError caught in bar()')
            raise

    def baz():
        try:
            bar()
        except ValueError as e:
            print('ValueError caught in baz()')

    baz()
    ```

    执行: 

    ```
    $ python main.py
    ValueError caught in bar()
    ValueError caught in baz()
    ```

    在这个函数中, 我们已经捕获到了错误, 但是又把错误通过`raise`抛出去了. 这样做的目的是为了将原始异常的信息向上传播, 实现和调用栈相似的功能. 如果没有在`bar()`将错误抛出, 如: 

    ```py
    def foo(s):
        n = int(s)
        if n == 0:
            raise ValueError('invalid value: %s' % s)
        return 10 / n

    def bar():
        try:
            foo('0')
        except ValueError as e:
            print('ValueError caught in bar()')

    def baz():
        try:
            bar()
        except ValueError as e:
            print('ValueError caught in baz()')

    baz()
    ```

    执行: 

    ```
    $ python main.py
    ValueError caught in bar()
    ```

    `baz()`和函数是不知道`bar`函数中发生了异常的, 这样就无法实现调用栈的功能. 

[^1]: 错误处理. (n.d.). Retrieved June 17, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017598873256736