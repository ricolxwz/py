---
name: 模块
icon: material/package-variant-closed
comments: true
---

## 模块、包和库

- 模块: 一堆函数、类、变量的集合
- 包: 一个包可能由多个模块组成
- 库: 一个库可能由多个包和模块组成

### 模块

以`.py`为后缀的文件, 称之为模块. 

???+ example "例子"

    假设现在有一个名为demo.py的文件: 

    ```py
    name = "wenzexu"
    print("导入成功")
    ```

    直接使用`import`语句就能导入, 导入之后, 可以使用`模块名.变量名`的方式访问这个变量:

    ```
    >>> import demo
    导入成功 # 由于未定义__name__, 导致顶层代码执行
    >>> demo.name
    'wenzexu'
    ```

???+ warning "注意"

    在导入模块之后, 模块之内所有未包裹在函数或者类里面的代码都会被执行. 如果你希望在导入包之后不执行顶层代码, 可以使用`__name__`参数. 这是一个特殊的内置变量, 一个文件被直接运行的时候, 其内部的`__name__`会被解释器设为`__main__`; 一个文件被作为模块导入的时候, `__name__`的值被设置为该模块的名字.

    ???+ example "例子"

        假设现在有一个名为demo.py的文件:

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        运行demo.py:

        ```sh
        $ python demo.py
        导入成功
        __main__
        ```

        在另一个文件run.py导入这个demo.py模块: 

        ```py
        import demo
        print(demo.name)
        ```

        运行run.py:

        ```sh
        $ python run.py
        wenzexu
        demo
        ```

    ???+ tip "Tip"

        可以使用`python`命令的`-m`选项用于直接运行模块, 该选项后接模块名. 当你使用这个选项之后, 解释器将制定的模块作为脚本执行, 而不仅仅是导入它. 这意味着模块中的所有代码都会被执行, 包括顶层代码, 即被`if __name__ == "__main__"`保护的代码块. 

???+ tip "Tip"

    当模块被导入之后, 会在当前目录下产生一个叫做`__pycache__`的缓存文件夹. 这里面的文件是模块被导入之后解释器根据模块代码编译生成的字节码. 这样如果以后再次运行的话. 如果调用的模块未发生改变, 那就直接跳过编译这一步, 直接去`__pycache__`文件夹里去运行相关的`*.pyc`文件, 大大缩短了项目运行前的准备时间.

    ???+ example "例子"

        ```sh
        $ tree .
        .
        ├── __pycache__
        │   └── demo.cpython-312.pyc
        ├── demo.py
        └── run.py
        ```

#### 作用域

在一个模块中, 我们可能定义很多的函数和变量, 有的函数和变量我们希望给别人使用, 有的函数和变量我们希望仅仅在模块内部使用, 这可以通过`_`前缀实现. 

???+ example "例子"

    ```py
    def _private_1(name):
    return 'Hello, %s' % name

    def _private_2(name):
        return 'Hi, %s' % name

    def greeting(name):
        if len(name) > 3:
            return _private_1(name)
        else:
            return _private_2(name)
    ```

???+ warning "注意"

    这种函数是"不应该"被直接引用, 而不是"不能"被直接引用, 这是一种约定俗称的方法, 告诉开发者这个函数不能引用. 在实例变量/函数的[访问限制](/基础/对象/#访问限制)也提到过这个概念. 

### 包

#### 常规包

在Python3.3之前, 一个包想要被导入使用, 包内必须要有`__init__.py`文件, 这个是Python识别一个文件夹是否为一个包的重要标志.

???+ example "例子"

    目录结构: 

    ```
    demo/
    ├── bar
    │   └── __init__.py
    ├── foo
    │   └── __init__.py
    └── __init__.py
    ```

    现在, 把`demo`下的`__init__.py`删除, 执行语句: 

    ```
    >>> import demo
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    ImportError: No module named demo
    ```

#### 命名空间包

在Python3.3之后, 即使一个文件夹中没有定义`__init__.py`, 也可以被作为命名空间包的形式导入.

???+ example "例子"

    目录结构:

    ```
    demo/
    ├── bar
    │   └── __init__.py
    └── foo
        └── __init__.py
    ```

    尝试导入`demo`: 

    ```
    >>> import demo
    ```

    并没有报错

### 库

库是一定功能代码的集合, 通常认为他是一个完整的项目打包.

## 导入

### 搜索路径 {#搜索路径}

当我们导入包或者模块的时候, Python解释器会在这两个地方寻找包或者模块:

1. `sys.path`
2. 运行文件所在的目录

???+ tip "Tip"

    可以通过`sys`模块查看`sys.path`.

    ???+ example "例子"

        ```
        >>> import sys
        >>> sys.path
        ['', '/usr/lib64/python39.zip', '/usr/lib64/python3.9', '/usr/lib64/python3.9/lib-dynload', '/usr/lib64/python3.9/site-packages', '/usr/lib/python3.9/site-packages']
        ```

### `import`

`import`只能用于导入包或者模块, 不能导入模块内部的变量/函数/类. 使用内部变量/函数/类的时候要加包或者模块的前缀.

- `import [module]`, 前缀: `[module]`
    - `import [module] as [alias]`
- `import [package].[module]` 前缀: `[package].[module]`
    - `import [package].[module] as [alias]`
- `import [package]`, 前缀: 无法加载包下的模块, 所以无法使用变量/函数/类

    ???+ warning "注意"

        这种情况下加载的其实是包下的`__init__.py`文件. 

        ??? example "例子"

            目录结构:

            ```sh
            .
            ├── pac
            │   ├── __init__.py
            │   └── demo.py
            └── run.py
            ```

            `__init__.py`文件:

            ```py
            print("hello")
            print(__name__)
            ```

            `run.py`文件:

            ```py
            import pac
            ```

            执行`run.py`

            ```sh
            $ python run.py
            hello
            demo
            ```

???+ example "例子"

    === "例子1"

        目录结构:

        ```sh
        .
        ├── demo.py
        └── run.py
        ```

        `demo.py`文件: 

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        `run.py`文件:

        ```py
        import demo

        print(demo.name)
        ```

        执行`run.py`: 

        ```sh
        $ python run.py
        wenzexu
        ```
    
    === "例子2"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件:

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        `run.py`文件:

        ```py
        import pac.demo

        print(pac.demo.name) 
        ```

        运行`run.py`:

        ```sh
        $ python run.py
        wenzexu
        ```

### `from ... import ...`

`from ... import ...`可以用于导入模块, 以及模块中的变量/函数/类, 但是不能用于导入包. 如果导入的是模块, 使用内部变量/函数/类的时候要加上前缀.

- `from [package] import [module]`, 前缀: `[module]`
- `from [module] import [var, function, class]`
- `from [package].[module] import [var, function, class]`
- `from [package].[module] import [var, function, class], [var, function, class]`
- `from [package].[module] import *`

???+ example "例子"

    === "例子1"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件: 

        ```py
        from pac.demo import name
        
        print(name)
        ```

        `run.py`文件:

        ```py
        name = "wenzexu"
        ```

        运行`run.py`文件:

        ```sh
        $ python run.py
        wenzexu
        ```
    
    === "例子2"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件: 

        ```py
        from pac import demo
        
        print(demo.name)
        ```

        `run.py`文件:

        ```py
        name = "wenzexu"
        ```

        运行`run.py`文件:

        ```sh
        $ python run.py
        wenzexu
        ```

#### 绝对导入和相对导入

绝对导入指的是从根目录开始导入模块. 相对导入指的是从当前文件所在的目录开始导入模块. 

相对导入的写法为:

- `from . import [module]`: 导入和自己相同目录下的模块
- `from .[package] import [module]`: 导入和自己相同目录的包的模块
- `from .. import [module]`: 导入上级目录的模块
- `from ..[package] import [module]`: 导入位于上级目录下的包的模块

???+ example "例子"

    === "例子1"

        目录结构:

        ```py
        .
        ├── a.py
        ├── b.py
        └── step
            ├── c.py
            └── d.py
        ```

        `c.py`文件内容: 

        ```py
        import d # 在Python3中导致报错

        def printSelf():
            print("In c")
        ```

        `a.py`文件内容:

        ```py
        from step import c

        c.printSelf()
        ```

        上述运行`a.py`之后会报错, 因为`a.py`导入`c.py`之后, 再要导入`d.py`, 由于`a.py`和`d.py`在不同的目录下, 所以`c.py`导入`d.py`的时候会报错. 上述的写法在Python2里面没问题, 但是在Python3里面会报错. 因为这种写法在Python2里面是相对导入, 在Python3里面是绝对导入. 

    === "例子2"

        目录结构:

        ```py
        .
        ├── a.py
        ├── b.py
        └── step
            ├── c.py
            └── d.py
        ```

        `c.py`文件内容: 

        ```py
        from . import d # 采用相对导入的写法

        def printSelf():
            print("In c")
        ```

        `a.py`文件内容:

        ```py
        from step import c

        c.printSelf()
        ```

        运行`a.py`:

        ```sh
        $ python a.py
        In c
        ```

        这样使用相对导入就没问题了.

## 打包

打包指的是将一个项目打包成可分发的格式, 以便其他用户或者开发者能够轻松安装和使用. 打包主要可以分为以下几类: 

- 原分发包: sdist, 包含了项目的源代码, 通常以`.tar.gz`格式发布, 这种包在安装时需要根据源码进行构建和编译(如过有需要编译的部分, 如C扩展; 如果为纯Python代码, 不需要编译), 常用的工具是setuptools
- 二进制分发包: bdist, 包含了预编译的二进制文件, 通常以`.whl`格式发布, 这种包在安装需要根据远吗进行构建, 但是不需要编译(已经包含了预编译的文件, 无论是C扩展还是其他二进制依赖), 常用的工具是setuptools
- 独立可执行文件: 这种文件将Python代码和解释器以及搜索的依赖打包在一起, 生成一个可以在没有解释器的环境中运行的单独可执行文件, 常用的工具有pyinstaller, cx_Freeze和py2exe

此外, 我们可以通过twine将打包好的包上传到[PYPI](https://pypi.org).

### `setuptools`打包

???+ warning "注意"

    需要先安装`setuptools`: `pip install setuptools`.

??? example "例子"

    项目结构:

    ```
    .
    ├── LICENSE
    ├── MANIFEST.in
    ├── README.md
    ├── mypackage
    │   ├── __init__.py
    │   ├── __version__.py
    │   └── core.py
    └── setup.py
    ```

    `MANIFEST.in`文件: 

    ```
    include README.md LICENSE
    ```

    `__init__.py`文件:

    ```py
    from .core import *
    ```

    `__version__.py`文件:

    ```py
    # 8b    d8 Yb  dP 88""Yb    db     dP""b8 88  dP    db     dP""b8 888888
    # 88b  d88  YbdP  88__dP   dPYb   dP   `" 88odP    dPYb   dP   `" 88__
    # 88YbdP88   8P   88"""   dP__Yb  Yb      88"Yb   dP__Yb  Yb  "88 88""
    # 88 YY 88  dP    88     dP""""Yb  YboodP 88  Yb dP""""Yb  YboodP 888888

    VERSION = (5, 2, 0)

    __version__ = '.'.join(map(str, VERSION))
    ```

    `core.py`文件:

    ```py
    # Insert your code here.
    ```

    `setup.py`文件:

    ```py
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-

    # Note: To use the 'upload' functionality of this file, you must:
    #   $ pipenv install twine --dev

    import io
    import os
    import sys
    from shutil import rmtree

    from setuptools import find_packages, setup

    # Package meta-data.
    NAME = '[name]'
    DESCRIPTION = '[desc]'
    URL = 'https://github.com/ricolxwz/[repo]'
    EMAIL = 'ricol.xwz@outlook.com'
    AUTHOR = 'ricolxwz'
    REQUIRES_PYTHON = '>=3.6.0'
    VERSION = '0.1.0'

    # What packages are required for this module to be executed?
    REQUIRED = [
        # 'requests', 'maya', 'records',
    ]

    # What packages are optional?
    EXTRAS = {
        # 'fancy feature': ['django'],
    }

    # The rest you shouldn't have to touch too much :)
    # ------------------------------------------------
    # Except, perhaps the License and Trove Classifiers!
    # If you do change the License, remember to change the Trove Classifier for that!

    here = os.path.abspath(os.path.dirname(__file__))

    # Import the README and use it as the long-description.
    # Note: this will only work if 'README.md' is present in your MANIFEST.in file!
    try:
        with io.open(os.path.join(here, 'README.md'), encoding='utf-8') as f:
            long_description = '\n' + f.read()
    except FileNotFoundError:
        long_description = DESCRIPTION

    # Load the package's __version__.py module as a dictionary.
    about = {}
    if not VERSION:
        project_slug = NAME.lower().replace("-", "_").replace(" ", "_")
        with open(os.path.join(here, project_slug, '__version__.py')) as f:
            exec(f.read(), about)
    else:
        about['__version__'] = VERSION

    # Where the magic happens:
    setup(
        name=NAME,
        version=about['__version__'],
        description=DESCRIPTION,
        long_description=long_description,
        long_description_content_type='text/markdown',
        author=AUTHOR,
        author_email=EMAIL,
        python_requires=REQUIRES_PYTHON,
        url=URL,
        packages=find_packages(exclude=["tests", "*.tests", "*.tests.*", "tests.*"]),
        # If your package is a single module, use this instead of 'packages':
        # py_modules=['mypackage'],

        # entry_points={
        #     'console_scripts': ['mycli=mymodule:cli'],
        # },
        install_requires=REQUIRED,
        extras_require=EXTRAS,
        include_package_data=True,
        license='MIT',
        classifiers=[
            # Trove classifiers
            # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers
            'License :: OSI Approved :: MIT License',
            'Programming Language :: Python',
            'Programming Language :: Python :: 3',
            'Programming Language :: Python :: 3.6',
            'Programming Language :: Python :: Implementation :: CPython',
            'Programming Language :: Python :: Implementation :: PyPy'
        ],
    )
    ```

#### 包内容

默认情况下, `setuptools`在构建包的时候会包含以下内容: 

1. Python包: 通过`find_packages()`找到的所有包
2. 由`package_data`指定的文件
3. 由`MANIFEST.in`指定的文件

???+ warning "注意"

    使用后两种方法必须要设置`include_package_data = True`

???+ example "例子"

    === "`package_data`"

        ???+ warning "注意"

            由`package_data`参数指定的文件必须包含在包目录内, 不能指定包含包外面的文件, 如果文件位于包外, 则需要先将其移动到包外面, 然后使用`MAINIFEST.in`指定.
        
        项目结构: 

        ```
        myproject/
        ├── mypackage/
        │   ├── __init__.py
        │   ├── module.py
        │   └── data/
        │       ├── config.json
        │       └── sample_data.csv
        ├── README.md
        └── setup.py
        ```

        `setup.py`文件: 

        ```py
        from setuptools import setup, find_packages

        setup(
            name='mypackage',
            version='0.1.0',
            description='A simple example package',
            long_description=open('README.md').read(),
            long_description_content_type='text/markdown',
            author='Your Name',
            author_email='your.email@example.com',
            url='https://github.com/yourname/mypackage',
            packages=find_packages(),
            include_package_data=True,  # 必须启用这个选项
            package_data={
                # 包含在 mypackage 中的所有文件
                'mypackage': ['data/*.json', 'data/*.csv'],
            },
            python_requires='>=3.6',
        )
        ```

        这种情况下, 如果你运行`python setup.py sdist`, 默认情况下, 源分发包只会包含`mypackage`目录以及其中的模块以及包外的`README.md`和`LICENSE`等必要文件, 其他的文件, 如`data/config.json`和`data/sample_data.csv`不会包含在源分发包中. 为了包含着这两个文件, 使用了`package_data`指定这些文件需要包含到打包好的包里面. 

    === "`MANIFEST.in`"

        ???+ note "笔记"

            由`MANIFEST.in`指定的文件可以在包内也可以在包外.

        项目结构:

        ```
        myproject/
        ├── mypackage/
        │   ├── __init__.py
        │   └── module.py
        ├── README.md
        ├── setup.py
        └── data/
            └── dataset.csv
        ```

        `setup.py`文件:

        ```py
        from setuptools import setup, find_packages

        setup(
            name='mypackage',
            version='0.1.0',
            description='A simple example package',
            long_description=open('README.md').read(),
            long_description_content_type='text/markdown',
            author='Your Name',
            author_email='your.email@example.com',
            url='https://github.com/yourname/mypackage',
            packages=find_packages(),
            include_package_data=True,
            python_requires='>=3.6',
        )
        ```

        这种情况下, 如果你运行`python setup.py sdist`, 默认情况下, 源分发包只会包含`mypackage`目录以及其中的模块以及包外的`README.md`和`LICENSE`等必要文件, 其他的文件, 如`data/dataset.csv`不会包含在源分发包中.

        为了包含着两个文件, 可以创建一个`MANIFEST.in`, 并指定这些文件:

        ```
        recursive-include data *.csv
        ```

        再次运行时, 源分发包将包含: 

        - `mypackage/`目录以及其中的所有模块以及包外的`README.md`和`LICENSE`等必要文件
        - `data/`目录以及其中所有的`.csv`文件

#### 打包

可以通过`python setup.py sdist`生成原分法包, 或者使用`python setup.py bdist_wheel`生成二进制分发包, 打包后的文件放在dist文件夹中, 扩展名分别为`.tar.gz`和`.whl`. 

???+ warning "注意"

    在打包之前, 需要清理掉之前所有打包产生的文件: `rm -rf build dist *.egg-info`

#### 参数

##### 描述

我们可以在`setup.py`中将`long_description`设置为项目下的`README.md`文件:

???+ example "例子"

    ```py
    here = os.path.abspath(os.path.dirname(__file__))

    # Import the README and use it as the long-description.
    # Note: this will only work if 'README.md' is present in your MANIFEST.in file!
    try:
        with io.open(os.path.join(here, 'README.md'), encoding='utf-8') as f:
            long_description = '\n' + f.read()
    except FileNotFoundError:
            long_description = DESCRIPTION
    ```

    `__file__`在这里时`setup.py`的文件名, `here`保存的是`setup.py`的绝对路径. 我们将`README.md`文件读出, 然后赋值给`long_description`. 最后在`setup()`函数中设置.

##### 版本

我们可以将版本设置为包目录下`__version__.py`文件中设置的版本:

???+ example "例子"

    `setup.py`文件(部分):

    ```py
    # Load the package's __version__.py module as a dictionary.
    about = {}
    if not VERSION:
        project_slug = NAME.lower().replace("-", "_").replace(" ", "_")
        with open(os.path.join(here, project_slug, '__version__.py')) as f:
            exec(f.read(), about)
    else:
        about['__version__'] = VERSION
    ```

    `__version__.py`文件:

    ```py
    `__version__.py`文件:

    ```py
    # 8b    d8 Yb  dP 88""Yb    db     dP""b8 88  dP    db     dP""b8 888888
    # 88b  d88  YbdP  88__dP   dPYb   dP   `" 88odP    dPYb   dP   `" 88__
    # 88YbdP88   8P   88"""   dP__Yb  Yb      88"Yb   dP__Yb  Yb  "88 88""
    # 88 YY 88  dP    88     dP""""Yb  YboodP 88  Yb dP""""Yb  YboodP 888888

    VERSION = (5, 2, 0)

    __version__ = '.'.join(map(str, VERSION))
    ```

    找到`__version__.py`文件之后, 使用`exec()`执行里面的代码, 第二个参数指定了一个命名空间.

    ???+ example "例子"

        ```py
        code = 'a = 5\nb = 10\nprint(a + b)'
        namespace = {}
        exec(code, namespace)
        print(namespace)  # {'a': 5, 'b': 10}
        ```

    将其版本保存到`about`这个字典中, 在`setup()`函数中使用. 如果没找到这个文件的话, 使用的是`setup.py`中定义的`VERSION`变量的值. 

##### 依赖

`setup()`函数中的`install_requires`用于指定核心依赖, `extras_require`用于指定可选依赖. 

- `install_requires`指定的依赖无论用户以何种方式安装你的包, 这些都会被安装.

    ???+ example "例子"

        ```py
        from setuptools import setup

        REQUIRED = [
            'numpy>=1.18.0',
            'pandas>=1.0.0',
        ]

        setup(
            ...
            install_requires=REQUIRED,
            ...
        )
        ```

- `extras_require`指定的是可选依赖, 可以为你的包指定一些额外的依赖, 但不是必需品, 用户可以选择是否安装这些依赖.

    ???+ example "例子"

        ```py
        from setuptools import setup

        EXTRAS = {
            'dev': ['check-manifest'],
            'test': ['coverage'],
        }

        setup(
            ...
            extras_require=EXTRAS,
            ...
        )
        ```

        用户可以通过以下命令安装可选依赖: 

        ```sh
        pip install your_package_name[dev]
        pip install your_package_name[test]
        ```

##### 其他参数

简短解释一下`setup()`函数中的其他参数以及复习一下已经讲过的参数:

- `name`: 包的名称

    ???+ tip "Tip"

        包的名称中的连字符用`-`, 而实际包的名字中的连字符用`_`, 因为导入包的时候带有`-`的包需要用到`importlib`, 比较麻烦.

- `verision`: 包的版本号
- `description`: 包的简短描述
- `long_description`: 包的详细描述
- `long_description_content_type`: 包的详细描述的文件类型, 一般是`text/markdown`
- `author`: 包的作者
- `author_email`: 包的作者的邮箱
- `python_requires`: 指定Python的版本范围
- `url`: 包的主页地址
- `packages`: 指定要打的包, 可以使用`find_packages()`函数自动寻找要打的包
- `py_modules`: 如果是单个模块, 使用的不是`package`而是`py_modules`
- `entry_point`: 定义包的命令行脚本入口点
- `install_requires`: 指定核心依赖
- `extras_require`: 指定可选依赖
- `include_package_data`: 设置是否可以包含其他文件
- `license`: 包的许可证
- `classifiers`: 分类标签, 帮助用户找到你的包
- `cmdclass`: 支持在命令行运行自定义命令

## 上传

### `twine`上传

???+ warning "注意"

    需要先安装`twine`: `pip install twine`.

可以通过`twine upload dist/*`命令将`dist`文件夹下的所有包都上传到[PYPI](https://pypi.org).

???+ tip "Tip"

    - 可以先上传到[TestPYPI](https://test.pypi.org/)检测一下自己的包是否正常, 是否可以通过`pip`下载安装. 

        ```
        twine upload --repository testpypi dist/*
        ```

    - 可以在用户目录`~`下创建一个文件`.pypirc`保存自己的Token: 

        ```
        [pypi]
        username = __token__
        password = [token]

        [testpypi]
        username = __token__
        password = [token]
        ```

[^1]: 【基础】什么是包、模块和库？—Python&图像处理教程 文档. (n.d.). Retrieved June 15, 2024, from http://await.fun/PythonTutorial/p06/1.html
[^2]: python中import的用法—PythonJoy. (n.d.). Retrieved June 15, 2024, from https://joy9191.github.io/16196181446571.html
[^3]: 以python -m site命令为例解释-m选项-CSDN博客. (n.d.). Retrieved June 16, 2024, from https://blog.csdn.net/jiaxin576/article/details/138574683
[^4]: 使用模块. (n.d.). Retrieved June 16, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017455068170048
[^5]: ennethreitz/setup.py: 📦 A Human’s Ultimate Guide to setup.py. (n.d.). Retrieved June 16, 2024, from https://github.com/kennethreitz/setup.py