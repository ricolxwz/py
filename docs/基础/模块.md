---
name: 模块
icon: material/package-variant-closed
comments: true
---

## 模块、包和库

- 模块: 一堆函数、类、变量的集合
- 包: 一个包可能由多个模块组成
- 库: 一个库可能由多个包和模块组成

### 模块

以`.py`为后缀的文件, 称之为模块. 

???+ example "例子"

    假设现在有一个名为demo.py的文件: 

    ```py
    name = "wenzexu"
    print("导入成功")
    ```

    直接使用`import`语句就能导入, 导入之后, 可以使用`模块名.变量名`的方式访问这个变量:

    ```
    >>> import demo
    导入成功 # 由于未定义__name__, 导致顶层代码执行
    >>> demo.name
    'wenzexu'
    ```

???+ warning "注意"

    在导入模块之后, 模块之内所有未包裹在函数或者类里面的代码都会被执行. 如果你希望在导入包之后不执行顶层代码, 可以使用`__name__`参数. 这是一个特殊的内置变量, 一个文件被直接运行的时候, 其内部的`__name__`会被解释器设为`__main__`; 一个文件被作为模块导入的时候, `__name__`的值被设置为该模块的名字.

    ???+ example "例子"

        假设现在有一个名为demo.py的文件:

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        运行demo.py:

        ```sh
        $ python demo.py
        导入成功
        __main__
        ```

        在另一个文件run.py导入这个demo.py模块: 

        ```py
        import demo
        print(demo.name)
        ```

        运行run.py:

        ```sh
        $ python run.py
        wenzexu
        demo
        ```

    ??? tip "Tip"

        可以使用`python`命令的`-m`选项用于直接运行模块, 该选项后接模块名. 当你使用这个选项之后, 解释器将制定的模块作为脚本执行, 而不仅仅是导入它. 这意味着模块中的所有代码都会被执行, 包括顶层代码, 即被`if __name__ == "__main__"`保护的代码块. 

???+ tip "Tip"

    当模块被导入之后, 会在当前目录下产生一个叫做`__pycache__`的缓存文件夹. 这里面的文件是模块被导入之后解释器根据模块代码编译生成的字节码. 这样如果以后再次运行的话. 如果调用的模块未发生改变, 那就直接跳过编译这一步, 直接去`__pycache__`文件夹里去运行相关的`*.pyc`文件, 大大缩短了项目运行前的准备时间.

    ???+ example "例子"

        ```sh
        $ tree .
        .
        ├── __pycache__
        │   └── demo.cpython-312.pyc
        ├── demo.py
        └── run.py
        ```

### 包

#### 常规包

在Python3.3之前, 一个包想要被导入使用, 包内必须要有`__init__.py`文件, 这个是Python识别一个文件夹是否为一个包的重要标志.

???+ example "例子"

    目录结构: 

    ```
    demo/
    ├── bar
    │   └── __init__.py
    ├── foo
    │   └── __init__.py
    └── __init__.py
    ```

    现在, 把`demo`下的`__init__.py`删除, 执行语句: 

    ```
    >>> import demo
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    ImportError: No module named demo
    ```

#### 命名空间包

在Python3.3之后, 即使一个文件夹中没有定义`__init__.py`, 也可以被作为命名空间包的形式导入.

???+ example "例子"

    目录结构:

    ```
    demo/
    ├── bar
    │   └── __init__.py
    └── foo
        └── __init__.py
    ```

    尝试导入`demo`: 

    ```
    >>> import demo
    ```

    并没有报错

## 导入

### 搜索路径 {#搜索路径}

当我们导入包或者模块的时候, Python解释器会在这两个地方寻找包或者模块:

1. `sys.path`
2. 运行文件所在的目录

???+ tip "Tip"

    可以通过`sys`模块查看`sys.path`.

    ???+ example "例子"

        ```
        >>> import sys
        >>> sys.path
        ['', '/usr/lib64/python39.zip', '/usr/lib64/python3.9', '/usr/lib64/python3.9/lib-dynload', '/usr/lib64/python3.9/site-packages', '/usr/lib/python3.9/site-packages']
        ```

### `import`

`import`只能用于导入包或者模块, 不能导入模块内部的变量/函数/类. 使用内部变量/函数/类的时候要加包或者模块的前缀.

- `import [module]`, 前缀: `[module]`
    - `import [module] as [alias]`
- `import [package].[module]` 前缀: `[package].[module]`
    - `import [package].[module] as [alias]`
- `import [package]`, 前缀: 无法加载包下的模块, 所以无法使用变量/函数/类

    ???+ warning "注意"

        这种情况下加载的其实是包下的`__init__.py`文件. 

        ??? example "例子"

            目录结构:

            ```sh
            .
            ├── pac
            │   ├── __init__.py
            │   └── demo.py
            └── run.py
            ```

            `__init__.py`文件:

            ```py
            print("hello")
            print(__name__)
            ```

            `run.py`文件:

            ```py
            import pac
            ```

            执行`run.py`

            ```sh
            $ python run.py
            hello
            demo
            ```

???+ example "例子"

    === "例子1"

        目录结构:

        ```sh
        .
        ├── demo.py
        └── run.py
        ```

        `demo.py`文件: 

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        `run.py`文件:

        ```py
        import demo

        print(demo.name)
        ```

        执行`run.py`: 

        ```sh
        $ python run.py
        wenzexu
        ```
    
    === "例子2"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件:

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        `run.py`文件:

        ```py
        import pac.demo

        print(pac.demo.name) 
        ```

        运行`run.py`:

        ```sh
        $ python run.py
        wenzexu
        ```

### `from ... import ...`

`from ... import ...`可以用于导入模块, 以及模块中的变量/函数/类, 但是不能用于导入包. 如果导入的是模块, 使用内部变量/函数/类的时候要加上前缀.

- `from [package] import [module]`, 前缀: `[module]`
- `from [module] import [var, function, class]`
- `from [package].[module] import [var, function, class]`
- `from [package].[module] import [var, function, class], [var, function, class]`

???+ example "例子"

    === "例子1"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件: 

        ```py
        from pac.demo import name
        
        print(name)
        ```

        `run.py`文件:

        ```py
        name = "wenzexu"
        ```

        运行`run.py`文件:

        ```sh
        $ python run.py
        wenzexu
        ```
    
    === "例子2"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件: 

        ```py
        from pac import demo
        
        print(demo.name)
        ```

        `run.py`文件:

        ```py
        name = "wenzexu"
        ```

        运行`run.py`文件:

        ```sh
        $ python run.py
        wenzexu
        ```

#### 绝对导入和相对导入

绝对导入指的是从根目录开始导入模块. 相对导入指的是从当前文件所在的目录开始导入模块. 

相对导入的写法为:

- `from . import [module]`: 导入和自己相同目录下的模块
- `from .[package] import [module]`: 导入和自己相同目录的包的模块
- `from .. import [module]`: 导入上级目录的模块
- `from ..[package] import [module]`: 导入位于上级目录下的包的模块

???+ example "例子"

    === "例子1"

        目录结构:

        ```py
        .
        ├── a.py
        ├── b.py
        └── step
            ├── c.py
            └── d.py
        ```

        `c.py`文件内容: 

        ```py
        import d # 在Python3中导致报错

        def printSelf():
            print("In c")
        ```

        `a.py`文件内容:

        ```py
        from step import c

        c.printSelf()
        ```

        上述运行`a.py`之后会报错, 因为`a.py`导入`c.py`之后, 再要导入`d.py`, 由于`a.py`和`d.py`在不同的目录下, 所以`c.py`导入`d.py`的时候会报错. 上述的写法在Python2里面没问题, 但是在Python3里面会报错. 因为这种写法在Python2里面是相对导入, 在Python3里面是绝对导入. 

    === "例子2"

        目录结构:

        ```py
        .
        ├── a.py
        ├── b.py
        └── step
            ├── c.py
            └── d.py
        ```

        `c.py`文件内容: 

        ```py
        from . import d # 采用相对导入的写法

        def printSelf():
            print("In c")
        ```

        `a.py`文件内容:

        ```py
        from step import c

        c.printSelf()
        ```

        运行`a.py`:

        ```sh
        $ python a.py
        In c
        ```

        这样使用相对导入就没问题了.

[^1]: 【基础】什么是包、模块和库？—Python&图像处理教程 文档. (n.d.). Retrieved June 15, 2024, from http://await.fun/PythonTutorial/p06/1.html
[^2]: python中import的用法—PythonJoy. (n.d.). Retrieved June 15, 2024, from https://joy9191.github.io/16196181446571.html
[^3]: 以python -m site命令为例解释-m选项-CSDN博客. (n.d.). Retrieved June 16, 2024, from https://blog.csdn.net/jiaxin576/article/details/138574683