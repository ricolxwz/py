---
name: 模块
icon: material/package-variant-closed
comments: true
---

## 模块、包和库

- 模块: 一堆函数、类、变量的集合
- 包: 一个包可能由多个模块组成
- 库: 一个库可能由多个包和模块组成

### 模块

以`.py`为后缀的文件, 称之为模块. 

???+ example "例子"

    假设现在有一个名为demo.py的文件: 

    ```py
    name = "wenzexu"
    print("导入成功")
    ```

    直接使用`import`语句就能导入, 导入之后, 可以使用`模块名.变量名`的方式访问这个变量:

    ```
    >>> import demo
    导入成功 # 由于未定义__name__, 导致顶层代码执行
    >>> demo.name
    'wenzexu'
    ```

???+ warning "注意"

    在导入模块之后, 模块之内所有未包裹在函数或者类里面的代码都会被执行. 如果你希望在导入包之后不执行顶层代码, 可以使用`__name__`参数. 这是一个特殊的内置变量, 一个文件被直接运行的时候, 其内部的`__name__`会被解释器设为`__main__`; 一个文件被作为模块导入的时候, `__name__`的值被设置为该模块的名字.

    ???+ example "例子"

        假设现在有一个名为demo.py的文件:

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        运行demo.py:

        ```sh
        $ python demo.py
        导入成功
        __main__
        ```

        在另一个文件run.py导入这个demo.py模块: 

        ```py
        import demo
        print(demo.name)
        ```

        运行run.py:

        ```sh
        $ python run.py
        wenzexu
        demo
        ```

    ???+ tip "Tip"

        可以使用`python`命令的`-m`选项用于直接运行模块, 该选项后接模块名. 当你使用这个选项之后, 解释器将制定的模块作为脚本执行, 而不仅仅是导入它. 这意味着模块中的所有代码都会被执行, 包括顶层代码, 即被`if __name__ == "__main__"`保护的代码块. 

???+ tip "Tip"

    当模块被导入之后, 会在当前目录下产生一个叫做`__pycache__`的缓存文件夹. 这里面的文件是模块被导入之后解释器根据模块代码编译生成的字节码. 这样如果以后再次运行的话. 如果调用的模块未发生改变, 那就直接跳过编译这一步, 直接去`__pycache__`文件夹里去运行相关的`*.pyc`文件, 大大缩短了项目运行前的准备时间.

    ???+ example "例子"

        ```sh
        $ tree .
        .
        ├── __pycache__
        │   └── demo.cpython-312.pyc
        ├── demo.py
        └── run.py
        ```

#### 作用域

在一个模块中, 我们可能定义很多的函数和变量, 有的函数和变量我们希望给别人使用, 有的函数和变量我们希望仅仅在模块内部使用, 这可以通过`_`前缀实现. 

???+ example "例子"

    ```py
    def _private_1(name):
    return 'Hello, %s' % name

    def _private_2(name):
        return 'Hi, %s' % name

    def greeting(name):
        if len(name) > 3:
            return _private_1(name)
        else:
            return _private_2(name)
    ```

???+ warning "注意"

    这种函数是"不应该"被直接引用, 而不是"不能"被直接引用, 这是一种约定俗称的方法, 告诉开发者这个函数不能引用. 在实例变量/函数的[访问限制](/基础/对象/#访问限制)也提到过这个概念. 

### 包

#### 常规包

在Python3.3之前, 一个包想要被导入使用, 包内必须要有`__init__.py`文件, 这个是Python识别一个文件夹是否为一个包的重要标志.

???+ example "例子"

    目录结构: 

    ```
    demo/
    ├── bar
    │   └── __init__.py
    ├── foo
    │   └── __init__.py
    └── __init__.py
    ```

    现在, 把`demo`下的`__init__.py`删除, 执行语句: 

    ```
    >>> import demo
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    ImportError: No module named demo
    ```

#### 命名空间包

在Python3.3之后, 即使一个文件夹中没有定义`__init__.py`, 也可以被作为命名空间包的形式导入.

???+ example "例子"

    目录结构:

    ```
    demo/
    ├── bar
    │   └── __init__.py
    └── foo
        └── __init__.py
    ```

    尝试导入`demo`: 

    ```
    >>> import demo
    ```

    并没有报错

### 库

库是一定功能代码的集合, 通常认为他是一个完整的项目打包.

## 导入

### 搜索路径 {#搜索路径}

当我们导入包或者模块的时候, Python解释器会在这两个地方寻找包或者模块:

1. `sys.path`
2. 运行文件所在的目录

???+ tip "Tip"

    可以通过`sys`模块查看`sys.path`.

    ???+ example "例子"

        ```
        >>> import sys
        >>> sys.path
        ['', '/usr/lib64/python39.zip', '/usr/lib64/python3.9', '/usr/lib64/python3.9/lib-dynload', '/usr/lib64/python3.9/site-packages', '/usr/lib/python3.9/site-packages']
        ```

### `import`

`import`只能用于导入包或者模块, 不能导入模块内部的变量/函数/类. 使用内部变量/函数/类的时候要加包或者模块的前缀.

- `import [module]`, 前缀: `[module]`
    - `import [module] as [alias]`
- `import [package].[module]` 前缀: `[package].[module]`
    - `import [package].[module] as [alias]`
- `import [package]`, 前缀: 无法加载包下的模块, 所以无法使用变量/函数/类

    ???+ warning "注意"

        这种情况下加载的其实是包下的`__init__.py`文件. 

        ??? example "例子"

            目录结构:

            ```sh
            .
            ├── pac
            │   ├── __init__.py
            │   └── demo.py
            └── run.py
            ```

            `__init__.py`文件:

            ```py
            print("hello")
            print(__name__)
            ```

            `run.py`文件:

            ```py
            import pac
            ```

            执行`run.py`

            ```sh
            $ python run.py
            hello
            demo
            ```

???+ example "例子"

    === "例子1"

        目录结构:

        ```sh
        .
        ├── demo.py
        └── run.py
        ```

        `demo.py`文件: 

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        `run.py`文件:

        ```py
        import demo

        print(demo.name)
        ```

        执行`run.py`: 

        ```sh
        $ python run.py
        wenzexu
        ```
    
    === "例子2"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件:

        ```py
        name = "wenzexu"

        def main():
            print("导入成功")
            print(__name__)

        if __name__ == "__main__":
            main()
        ```

        `run.py`文件:

        ```py
        import pac.demo

        print(pac.demo.name) 
        ```

        运行`run.py`:

        ```sh
        $ python run.py
        wenzexu
        ```

### `from ... import ...`

`from ... import ...`可以用于导入模块, 以及模块中的变量/函数/类, 但是不能用于导入包. 如果导入的是模块, 使用内部变量/函数/类的时候要加上前缀.

- `from [package] import [module]`, 前缀: `[module]`
- `from [module] import [var, function, class]`
- `from [package].[module] import [var, function, class]`
- `from [package].[module] import [var, function, class], [var, function, class]`

???+ example "例子"

    === "例子1"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件: 

        ```py
        from pac.demo import name
        
        print(name)
        ```

        `run.py`文件:

        ```py
        name = "wenzexu"
        ```

        运行`run.py`文件:

        ```sh
        $ python run.py
        wenzexu
        ```
    
    === "例子2"

        目录结构:

        ```sh
        .
        ├── pac
        │   ├── __init__.py
        │   └── demo.py
        └── run.py 
        ```

        `demo.py`文件: 

        ```py
        from pac import demo
        
        print(demo.name)
        ```

        `run.py`文件:

        ```py
        name = "wenzexu"
        ```

        运行`run.py`文件:

        ```sh
        $ python run.py
        wenzexu
        ```

#### 绝对导入和相对导入

绝对导入指的是从根目录开始导入模块. 相对导入指的是从当前文件所在的目录开始导入模块. 

相对导入的写法为:

- `from . import [module]`: 导入和自己相同目录下的模块
- `from .[package] import [module]`: 导入和自己相同目录的包的模块
- `from .. import [module]`: 导入上级目录的模块
- `from ..[package] import [module]`: 导入位于上级目录下的包的模块

???+ example "例子"

    === "例子1"

        目录结构:

        ```py
        .
        ├── a.py
        ├── b.py
        └── step
            ├── c.py
            └── d.py
        ```

        `c.py`文件内容: 

        ```py
        import d # 在Python3中导致报错

        def printSelf():
            print("In c")
        ```

        `a.py`文件内容:

        ```py
        from step import c

        c.printSelf()
        ```

        上述运行`a.py`之后会报错, 因为`a.py`导入`c.py`之后, 再要导入`d.py`, 由于`a.py`和`d.py`在不同的目录下, 所以`c.py`导入`d.py`的时候会报错. 上述的写法在Python2里面没问题, 但是在Python3里面会报错. 因为这种写法在Python2里面是相对导入, 在Python3里面是绝对导入. 

    === "例子2"

        目录结构:

        ```py
        .
        ├── a.py
        ├── b.py
        └── step
            ├── c.py
            └── d.py
        ```

        `c.py`文件内容: 

        ```py
        from . import d # 采用相对导入的写法

        def printSelf():
            print("In c")
        ```

        `a.py`文件内容:

        ```py
        from step import c

        c.printSelf()
        ```

        运行`a.py`:

        ```sh
        $ python a.py
        In c
        ```

        这样使用相对导入就没问题了.

## 打包

打包指的是将一个项目打包成可分发的格式, 以便其他用户或者开发者能够轻松安装和使用. 打包主要可以分为以下几类: 

- 原分发包: sdist, 包含了项目的源代码, 通常以`.tar.gz`格式发布, 这种包在安装时需要根据源码进行构建和编译(如过有需要编译的部分, 如C扩展; 如果为纯Python代码, 不需要编译), 常用的工具是setuptools
- 二进制分发包: bdist, 包含了预编译的二进制文件, 通常以`.whl`格式发布, 这种包在安装需要根据远吗进行构建, 但是不需要编译(已经包含了预编译的文件, 无论是C扩展还是其他二进制依赖), 常用的工具是setuptools
- 独立可执行文件: 这种文件将Python代码和解释器以及搜索的依赖打包在一起, 生成一个可以在没有解释器的环境中运行的单独可执行文件, 常用的工具有pyinstaller, cx_Freeze和py2exe

此外, 我们可以通过twine将打包好的包上传到[PYPI](https://pypi.org).

### setuptools打包

需要在项目根目录下设置`setup.py`文件.

???+ example "例子"

    项目结构:

    ```
    .
    ├── LICENSE
    ├── MANIFEST.in
    ├── README.md
    ├── mypackage
    │   ├── __init__.py
    │   ├── __version__.py
    │   └── core.py
    └── setup.py
    ```

    `MANIFEST.in`文件: 

    ```
    include README.md LICENSE
    ```

    `__init__.py`文件:

    ```py
    from .core import *
    ```

    `__version__.py`文件:

    ```py
    # 8b    d8 Yb  dP 88""Yb    db     dP""b8 88  dP    db     dP""b8 888888
    # 88b  d88  YbdP  88__dP   dPYb   dP   `" 88odP    dPYb   dP   `" 88__
    # 88YbdP88   8P   88"""   dP__Yb  Yb      88"Yb   dP__Yb  Yb  "88 88""
    # 88 YY 88  dP    88     dP""""Yb  YboodP 88  Yb dP""""Yb  YboodP 888888

    VERSION = (5, 2, 0)

    __version__ = '.'.join(map(str, VERSION))
    ```

    `core.py`文件:

    ```py
    # Insert your code here.
    ```

    `setup.py`文件:

    ```py
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-

    # Note: To use the 'upload' functionality of this file, you must:
    #   $ pipenv install twine --dev

    import io
    import os
    import sys
    from shutil import rmtree

    from setuptools import find_packages, setup, Command

    # Package meta-data.
    NAME = 'mypackage'
    DESCRIPTION = 'My short description for my project.'
    URL = 'https://github.com/me/myproject'
    EMAIL = 'me@example.com'
    AUTHOR = 'Awesome Soul'
    REQUIRES_PYTHON = '>=3.6.0'
    VERSION = '0.1.0'

    # What packages are required for this module to be executed?
    REQUIRED = [
        # 'requests', 'maya', 'records',
    ]

    # What packages are optional?
    EXTRAS = {
        # 'fancy feature': ['django'],
    }

    # The rest you shouldn't have to touch too much :)
    # ------------------------------------------------
    # Except, perhaps the License and Trove Classifiers!
    # If you do change the License, remember to change the Trove Classifier for that!

    here = os.path.abspath(os.path.dirname(__file__))

    # Import the README and use it as the long-description.
    # Note: this will only work if 'README.md' is present in your MANIFEST.in file!
    try:
        with io.open(os.path.join(here, 'README.md'), encoding='utf-8') as f:
            long_description = '\n' + f.read()
    except FileNotFoundError:
        long_description = DESCRIPTION

    # Load the package's __version__.py module as a dictionary.
    about = {}
    if not VERSION:
        project_slug = NAME.lower().replace("-", "_").replace(" ", "_")
        with open(os.path.join(here, project_slug, '__version__.py')) as f:
            exec(f.read(), about)
    else:
        about['__version__'] = VERSION


    class UploadCommand(Command):
        """Support setup.py upload."""

        description = 'Build and publish the package.'
        user_options = []

        @staticmethod
        def status(s):
            """Prints things in bold."""
            print('\033[1m{0}\033[0m'.format(s))

        def initialize_options(self):
            pass

        def finalize_options(self):
            pass

        def run(self):
            try:
                self.status('Removing previous builds…')
                rmtree(os.path.join(here, 'dist'))
            except OSError:
                pass

            self.status('Building Source and Wheel (universal) distribution…')
            os.system('{0} setup.py sdist bdist_wheel --universal'.format(sys.executable))

            self.status('Uploading the package to PyPI via Twine…')
            os.system('twine upload dist/*')

            self.status('Pushing git tags…')
            os.system('git tag v{0}'.format(about['__version__']))
            os.system('git push --tags')

            sys.exit()


    # Where the magic happens:
    setup(
        name=NAME,
        version=about['__version__'],
        description=DESCRIPTION,
        long_description=long_description,
        long_description_content_type='text/markdown',
        author=AUTHOR,
        author_email=EMAIL,
        python_requires=REQUIRES_PYTHON,
        url=URL,
        packages=find_packages(exclude=["tests", "*.tests", "*.tests.*", "tests.*"]),
        # If your package is a single module, use this instead of 'packages':
        # py_modules=['mypackage'],

        # entry_points={
        #     'console_scripts': ['mycli=mymodule:cli'],
        # },
        install_requires=REQUIRED,
        extras_require=EXTRAS,
        include_package_data=True,
        license='MIT',
        classifiers=[
            # Trove classifiers
            # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers
            'License :: OSI Approved :: MIT License',
            'Programming Language :: Python',
            'Programming Language :: Python :: 3',
            'Programming Language :: Python :: 3.6',
            'Programming Language :: Python :: Implementation :: CPython',
            'Programming Language :: Python :: Implementation :: PyPy'
        ],
        # $ setup.py publish support.
        cmdclass={
            'upload': UploadCommand,
        },
    )
    ```

    ???+ note "笔记"

        === "解释1"



[^1]: 【基础】什么是包、模块和库？—Python&图像处理教程 文档. (n.d.). Retrieved June 15, 2024, from http://await.fun/PythonTutorial/p06/1.html
[^2]: python中import的用法—PythonJoy. (n.d.). Retrieved June 15, 2024, from https://joy9191.github.io/16196181446571.html
[^3]: 以python -m site命令为例解释-m选项-CSDN博客. (n.d.). Retrieved June 16, 2024, from https://blog.csdn.net/jiaxin576/article/details/138574683
[^4]: 使用模块. (n.d.). Retrieved June 16, 2024, from https://www.liaoxuefeng.com/wiki/1016959663602400/1017455068170048
[^5]: ennethreitz/setup.py: 📦 A Human’s Ultimate Guide to setup.py. (n.d.). Retrieved June 16, 2024, from https://github.com/kennethreitz/setup.py